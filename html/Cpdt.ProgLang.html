<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.ProgLang</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.ProgLang</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 Reasoning about the syntax and semantics of programming languages is a popular application of proof assistants.  Before proving the first theorem of this kind, it is necessary to choose a formal encoding of the informal notions of syntax, dealing with such issues as variable binding conventions.  I believe the pragmatic questions in this domain are far from settled and remain as important open research problems.  However, in this chapter, I will demonstrate two underused encoding approaches.  Note that I am not recommending either approach as a silver bullet!  Mileage will vary across concrete problems, and I expect there to be significant future advances in our knowledge of encoding techniques.  For a broader introduction to programming language formalization, using more elementary techniques, see <a href="http://www.cis.upenn.edu/~bcpierce/sf/">Software Foundations</a> by Pierce et al.

<div class="paragraph"> </div>

   This chapter is also meant as a case study, bringing together what we have learned in the previous chapters.  We will see a concrete example of the importance of representation choices; translating mathematics from paper to Coq is not a deterministic process, and different creative choices can have big impacts.  We will also see dependent types and scripted proof automation in action, applied to solve a particular problem as well as possible, rather than to demonstrate new Coq concepts.

<div class="paragraph"> </div>

   I apologize in advance to those readers not familiar with the theory of programming language semantics.  I will make a few remarks intended to relate the material here with common ideas in semantics, but these remarks should be safe for others to skip.

<div class="paragraph"> </div>

   We will define a small programming language and reason about its semantics, expressed as an interpreter into Coq terms, much as we have done in examples throughout the book.  It will be helpful to build a slight extension of <span class="inlinecode"><span class="id" title="var">crush</span></span> that tries to apply functional extensionality, an axiom we met in Chapter 12, which says that two functions are equal if they map equal inputs to equal outputs.  We also use <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> to simplify goals of a particular form that will come up with the term denotation function that we define shortly. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">ext</span> := <span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> "x" <span class="id" title="keyword">in</span> <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">pl</span> := <span class="id" title="var">crush</span>; <span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="notation">(</span><span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">_</span><span class="id" title="notation">)</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">_</span><span class="id" title="notation">)</span> ] ⇒ <span class="id" title="var">ext</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">E</span> <span class="id" title="var">_</span> <span class="id" title="notation">=</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">E</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">f_equal</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">E</span> <span class="id" title="notation">:::</span> <span class="id" title="var">_</span> <span class="id" title="notation">=</span> ?<span class="id" title="var">E</span> <span class="id" title="notation">:::</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">f_equal</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="definition">hmap</span> <span class="id" title="var">_</span> ?<span class="id" title="var">E</span> <span class="id" title="notation">=</span> <span class="id" title="definition">hmap</span> <span class="id" title="var">_</span> ?<span class="id" title="var">E</span> ] ⇒ <span class="id" title="tactic">f_equal</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>

<br/>
</div>

<div class="doc">
At this point in the book source, some auxiliary proofs also appear. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Here is a definition of the type system we will use throughout the chapter.  It is for simply typed lambda calculus with natural numbers as the base type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="type"><span class="id" title="inductive">type</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
| <a name="Nat"><span class="id" title="constructor">Nat</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a><br/>
| <a name="Func"><span class="id" title="constructor">Func</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="typeDenote"><span class="id" title="definition">typeDenote</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <span class="id" title="var">t1</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now we have some choices as to how we represent the syntax of programs.  The two sections of the chapter explore two such choices, demonstrating the effect the choice has on proof complexity. 
<div class="paragraph"> </div>

<a name="lab94"></a><h1 class="section">Dependent de Bruijn Indices</h1>

<div class="paragraph"> </div>

 The first encoding is one we met first in Chapter 9, the <i>dependent de Bruijn index</i> encoding.  We represent program syntax terms in a type family parameterized by a list of types, representing the <i>typing context</i>, or information on which free variables are in scope and what their types are.  Variables are represented in a way isomorphic to the natural numbers, where number 0 represents the first element in the context, number 1 the second element, and so on.  Actually, instead of numbers, we use the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#member"><span class="id" title="inductive">member</span></a></span> dependent type family from Chapter 9. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="FirstOrder"><span class="id" title="module">FirstOrder</span></a>.<br/>

<br/>
</div>

<div class="doc">
Here is the definition of the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> type, including variables, constants, addition, function abstraction and application, and let binding of local variables. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="FirstOrder.term"><span class="id" title="inductive">term</span></a> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="FirstOrder.Var"><span class="id" title="constructor">Var</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span>, <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a><br/>
<br/>
&nbsp;&nbsp;| <a name="FirstOrder.Const"><span class="id" title="constructor">Const</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span>, <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
&nbsp;&nbsp;| <a name="FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
<br/>
&nbsp;&nbsp;| <a name="FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>)<br/>
&nbsp;&nbsp;| <a name="FirstOrder.App"><span class="id" title="constructor">App</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a><br/>
<br/>
&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> [<span class="id" title="var">G</span>].<br/>

<br/>
</div>

<div class="doc">
Here are two example term encodings, the first of addition packaged as a two-argument curried function, and the second of a sample application of addition to constants. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="FirstOrder.add"><span class="id" title="definition">add</span></a> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="constructor">nil</span> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> (<span class="id" title="constructor">HNext</span> <span class="id" title="constructor">HFirst</span>)) (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="constructor">HFirst</span>))).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="FirstOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="constructor">nil</span> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.add"><span class="id" title="definition">add</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> 2).<br/>

<br/>
</div>

<div class="doc">
Since dependent typing ensures that any term is well-formed in its context and has a particular type, it is easy to translate syntactic terms into Coq values. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <span class="id" title="inductive">hlist</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="definition">hget</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="var">x</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span> (<a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e2</span> (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
With this term representation, some program transformations are easy to implement and prove correct.  Certainly we would be worried if this were not the the case for the <i>identity</i> transformation, which takes a term apart and reassembles it. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">x</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="FirstOrder.identSound"><span class="id" title="lemma">identSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.ident"><span class="id" title="definition">ident</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A slightly more ambitious transformation belongs to the family of <i>constant folding</i> optimizations we have used as examples in other chapters. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">G</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e1'</span> := <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e2'</span> := <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">maybeOpt</span> := <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <span class="id" title="keyword">return</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n1</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a> <span class="id" title="keyword">return</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n2</span> ⇒ <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> (<span class="id" title="var">n1</span> <span class="id" title="notation">+</span> <span class="id" title="var">n2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#maybeOpt"><span class="id" title="variable">maybeOpt</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">e'</span> ⇒ <span class="id" title="var">e'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">e</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The correctness proof is more complex, but only slightly so. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="FirstOrder.cfoldSound"><span class="id" title="lemma">cfoldSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">pl</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The transformations we have tried so far have been straightforward because they do not have interesting effects on the variable binding structure of terms.  The dependent de Bruijn representation is called <i>first-order</i> because it encodes variable identity explicitly; all such representations incur bookkeeping overheads in transformations that rearrange binding structure.

<div class="paragraph"> </div>

     As an example of a tricky transformation, consider one that removes all uses of "<span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a></span>" by substituting <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span> for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> in <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a></span>.  We will implement the translation by pairing the "compile-time" typing environment with a "run-time" value environment or <i>substitution</i>, mapping each variable to a value to be substituted for it.  Such a substitute term may be placed within a program in a position with a larger typing environment than applied at the point where the substitute term was chosen.  To support such context transplantation, we need <i>lifting</i>, a standard de Bruijn indices operation.  With dependent typing, lifting corresponds to weakening for typing judgments.

<div class="paragraph"> </div>

     The fundamental goal of lifting is to add a new variable to a typing context, maintaining the validity of a term in the expanded context.  To express the operation of adding a type to a context, we use a helper function <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<span class="id" title="var">G</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">n</span>} : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">t'</span> <span class="id" title="notation">::</span> <span class="id" title="var">G'</span> ⇒ <span class="id" title="var">t'</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="var">G'</span> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Another function lifts bound variable instances, which we represent with <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#member"><span class="id" title="inductive">member</span></a></span> values. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.liftVar"><span class="id" title="definition">liftVar</span></a> <span class="id" title="var">t</span> <span class="id" title="var">G</span> (<span class="id" title="var">x</span> : <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <span class="id" title="var">t'</span> <span class="id" title="var">n</span> : <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">HFirst</span> <span class="id" title="var">G'</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">return</span> <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> (<a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">::</span> <span class="id" title="var">G'</span>) <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="constructor">HNext</span> <span class="id" title="constructor">HFirst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">HFirst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">HNext</span> <span class="id" title="var">t''</span> <span class="id" title="var">G'</span> <span class="id" title="var">x'</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">return</span> <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> (<span class="id" title="var">t''</span> <span class="id" title="notation">::</span> <span class="id" title="var">G'</span>) <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="constructor">HNext</span> (<span class="id" title="constructor">HNext</span> <span class="id" title="var">x'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="constructor">HNext</span> (<a class="idref" href="Cpdt.ProgLang.html#liftVar"><span class="id" title="definition">liftVar</span></a> <span class="id" title="var">x'</span> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The final helper function for lifting allows us to insert a new variable anywhere in a typing context. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.lift'"><span class="id" title="definition">lift'</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t'</span> <span class="id" title="var">n</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.liftVar"><span class="id" title="definition">liftVar</span></a> <span class="id" title="var">x</span> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="var">e1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
In the <span class="inlinecode"><span class="id" title="keyword">Let</span></span> removal transformation, we only need to apply lifting to add a new variable at the <i>beginning</i> of a typing context, so we package lifting into this final, simplified form. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="FirstOrder.lift"><span class="id" title="definition">lift</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t'</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <span class="id" title="constructor">O</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>.<br/>

<br/>
</div>

<div class="doc">
Finally, we can implement <span class="inlinecode"><span class="id" title="keyword">Let</span></span> removal.  The argument of type <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#hlist"><span class="id" title="inductive">hlist</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a>)</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> represents a substitution mapping each variable from context <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> into a term that is valid in context <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a></span>.  Note how the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a></span> case (1) extends via lifting the substitution <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> to hold in the broader context of the abstraction body <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span> and (2) maps the new first variable to itself.  It is only the <span class="inlinecode"><span class="id" title="keyword">Let</span></span> case that maps a variable to any substitute beside itself. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">G'</span> : <span class="id" title="inductive">hlist</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a>) <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="definition">hget</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="var">x</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="constructor">HFirst</span> <span class="id" title="notation">:::</span> <span class="id" title="definition">hmap</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a> <span class="id" title="var">_</span>) <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">t1</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e2</span> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We have finished defining the transformation, but the parade of helper functions is not over.  To prove correctness, we will use one more helper function and a few lemmas.  First, we need an operation to insert a new value into a substitution at a particular position. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="FirstOrder.insertAtS"><span class="id" title="definition">insertAtS</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) (<span class="id" title="var">G</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">n</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">hlist</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">hlist</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <span class="id" title="keyword">return</span> <span class="id" title="inductive">hlist</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="inductive">hlist</span> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAt"><span class="id" title="definition">insertAt</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<span class="id" title="constructor">S</span> <span class="id" title="var">n'</span>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">t'</span> <span class="id" title="notation">::</span> <span class="id" title="var">G'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="definition">hhd</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#insertAtS"><span class="id" title="definition">insertAtS</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">n'</span> (<span class="id" title="definition">htl</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAtS"><span class="id" title="definition">insertAtS</span></a> [<span class="id" title="var">t</span> <span class="id" title="var">G</span>].<br/>

<br/>
</div>

<div class="doc">
Next we prove that <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.liftVar"><span class="id" title="definition">liftVar</span></a></span> is correct.  That is, a lifted variable retains its value with respect to a substitution when we perform an analogue to lifting by inserting a new mapping into the substitution. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FirstOrder.liftVarSound"><span class="id" title="lemma">liftVarSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t'</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a>) <span class="id" title="var">t</span> <span class="id" title="var">G</span> (<span class="id" title="var">m</span> : <span class="id" title="inductive">member</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <span class="id" title="var">s</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">hget</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Cpdt.ProgLang.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">=</span> <span class="id" title="definition">hget</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAtS"><span class="id" title="definition">insertAtS</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.liftVar"><span class="id" title="definition">liftVar</span></a> <a class="idref" href="Cpdt.ProgLang.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="var">dep_destruct</span> <span class="id" title="var">s</span>; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">liftVarSound</span>.<br/>

<br/>
</div>

<div class="doc">
An analogous lemma establishes correctness of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'"><span class="id" title="definition">lift'</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FirstOrder.lift'Sound"><span class="id" title="lemma">lift'Sound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t'</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a>) <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">n</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'"><span class="id" title="definition">lift'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.insertAtS"><span class="id" title="definition">insertAtS</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">IH</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">s</span>, <span class="id" title="var">_</span> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'"><span class="id" title="definition">lift'</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a> ?<span class="id" title="var">E</span>) <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'"><span class="id" title="definition">lift'</span></a> <span class="id" title="var">_</span> (<span class="id" title="constructor">S</span> ?<span class="id" title="var">N</span>) ?<span class="id" title="var">E</span>] ] ⇒ <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IH</span> (<span class="id" title="constructor">S</span> <span class="id" title="var">N</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Correctness of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a></span> itself is an easy corollary. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FirstOrder.liftSound"><span class="id" title="lemma">liftSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t'</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a>) <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:::</span> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift'Sound"><span class="id" title="lemma">lift'Sound</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span> <span class="id" title="constructor">O</span>); <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Rewrite</span> <span class="id" title="lemma">hget_hmap</span> <a class="idref" href="Cpdt.ProgLang.html#hmap_hmap"><span class="id" title="lemma">hmap_hmap</span></a> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.liftSound"><span class="id" title="lemma">liftSound</span></a>.<br/>

<br/>
</div>

<div class="doc">
Finally, we can prove correctness of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unletSound"><span class="id" title="lemma">unletSound</span></a></span> for terms in arbitrary typing environments. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="FirstOrder.unletSound'"><span class="id" title="lemma">unletSound'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">G'</span> (<span class="id" title="var">s</span> : <span class="id" title="inductive">hlist</span> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a>) <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) <span class="id" title="var">s1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.unlet"><span class="id" title="definition">unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>) <a class="idref" href="Cpdt.ProgLang.html#s1"><span class="id" title="variable">s1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> (<span class="id" title="definition">hmap</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t'</span> (<span class="id" title="var">e'</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a> <a class="idref" href="Cpdt.ProgLang.html#t'"><span class="id" title="variable">t'</span></a>) ⇒ <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="Cpdt.ProgLang.html#s1"><span class="id" title="variable">s1</span></a>) <a class="idref" href="Cpdt.ProgLang.html#s"><span class="id" title="variable">s</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The lemma statement is a mouthful, with all its details of typing contexts and substitutions.  It is usually prudent to state a final theorem in as simple a way as possible, to help your readers believe that you have proved what they expect.  We follow that advice here for the simple case of terms with empty typing contexts. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="FirstOrder.unletSound"><span class="id" title="lemma">unletSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="constructor">nil</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#FirstOrder.unlet"><span class="id" title="definition">unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="constructor">HNil</span>) <span class="id" title="constructor">HNil</span> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="constructor">HNil</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder.unletSound'"><span class="id" title="lemma">unletSound'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.ProgLang.html#FirstOrder"><span class="id" title="module">FirstOrder</span></a>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="keyword">Let</span></span> removal optimization is a good case study of a simple transformation that may turn out to be much more work than expected, based on representation choices.  In the second part of this chapter, we consider an alternate choice that produces a more pleasant experience. 
<div class="paragraph"> </div>

<a name="lab95"></a><h1 class="section">Parametric Higher-Order Abstract Syntax</h1>

<div class="paragraph"> </div>

 In contrast to first-order encodings, <i>higher-order</i> encodings avoid explicit modeling of variable identity.  Instead, the binding constructs of an <i>object language</i> (the language being formalized) can be represented using the binding constructs of the <i>meta language</i> (the language in which the formalization is done).  The best known higher-order encoding is called <i>higher-order abstract syntax</i> (HOAS) , and we can start by attempting to apply it directly in Coq. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="HigherOrder"><span class="id" title="module">HigherOrder</span></a>.<br/>

<br/>
</div>

<div class="doc">
With HOAS, each object language binding construct is represented with a <i>function</i> of the meta language.  Here is what we get if we apply that idea within an inductive definition of term syntax. 
<div class="paragraph"> </div>

 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> → <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a>, (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a>) → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a>) → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.DataStruct.html#dom"><span class="id" title="variable">dom</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.DataStruct.html#ran"><span class="id" title="variable">ran</span></a><br/>
<br/>
&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> → (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>) → <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   However, Coq rejects this definition for failing to meet the strict positivity restriction.  For instance, the constructor <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a></span> takes an argument that is a function over the same type family <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> that we are defining.  Inductive definitions of this kind can be used to write non-terminating Gallina programs, which breaks the consistency of Coq's logic.

<div class="paragraph"> </div>

   An alternate higher-order encoding is <i>parametric HOAS</i>, as introduced by Washburn and Weirich for Haskell and tweaked by me for use in Coq.  Here the idea is to parameterize the syntax type by a type family standing for a <i>representation of variables</i>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="HigherOrder.var"><span class="id" title="section">var</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="HigherOrder.var.var"><span class="id" title="variable">var</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="HigherOrder.term"><span class="id" title="inductive">term</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.Var"><span class="id" title="constructor">Var</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.Const"><span class="id" title="constructor">Const</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> : <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span>, <span class="id" title="notation">(</span><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.App"><span class="id" title="constructor">App</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>, <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var"><span class="id" title="section">var</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> [<span class="id" title="var">var</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> [<span class="id" title="var">var</span>].<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> [<span class="id" title="var">var</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span>].<br/>

<br/>
</div>

<div class="doc">
Coq accepts this definition because our embedded functions now merely take <i>variables</i> as arguments, instead of arbitrary terms.  One might wonder whether there is an easy loophole to exploit here, instantiating the parameter <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> as <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> itself.  However, to do that, we would need to choose a variable representation for this nested mention of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span>, and so on through an infinite descent into <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> arguments.

<div class="paragraph"> </div>

  We write the final type of a closed term using polymorphic quantification over all possible choices of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> type family. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Term"><span class="id" title="definition">Term</span></a> <span class="id" title="var">t</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">var</span>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>.<br/>

<br/>
</div>

<div class="doc">
Here are the new representations of the example terms from the last section.  Note how each is written as a function over a <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> choice, such that the specific choice has no impact on the <i>structure</i> of the term. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="HigherOrder.add"><span class="id" title="definition">add</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a>)) := <span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#y"><span class="id" title="variable">y</span></a>))).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.add"><span class="id" title="definition">add</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2).<br/>

<br/>
</div>

<div class="doc">
The argument <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> does not even appear in the function body for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.add"><span class="id" title="definition">add</span></a></span>.  How can that be?  By giving our terms expressive types, we allow Coq to infer many arguments for us.  In fact, we do not even need to name the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> argument! 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="HigherOrder.add'"><span class="id" title="definition">add'</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a>)) := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#y"><span class="id" title="variable">y</span></a>))).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="HigherOrder.three_the_hard_way'"><span class="id" title="definition">three_the_hard_way'</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.add'"><span class="id" title="definition">add'</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2).<br/>

<br/>
</div>

<div class="doc">
Even though the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> formal parameters appear as underscores, they <i>are</i> mentioned in the function bodies that type inference calculates. 
<div class="paragraph"> </div>

<a name="lab96"></a><h2 class="section">Functional Programming with PHOAS</h2>

<div class="paragraph"> </div>

 It may not be at all obvious that the PHOAS representation admits the crucial computable operations.  The key to effective deconstruction of PHOAS terms is one principle: treat the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> parameter as an unconstrained choice of <i>which data should be annotated on each variable</i>.  We will begin with a simple example, that of counting how many variable nodes appear in a PHOAS term.  This operation requires no data annotated on variables, so we simply annotate variables with <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span> values.  Note that, when we go under binders in the cases for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a></span> and <span class="inlinecode"><span class="id" title="keyword">Let</span></span>, we must provide the data value to annotate on the new variable we pass beneath.  For our current choice of <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span> data, we always pass <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">unit</span>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ 1<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">e2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> (<span class="id" title="var">e1</span> <span class="id" title="constructor">tt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">e2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.ProgLang.html#countVars"><span class="id" title="definition">countVars</span></a> (<span class="id" title="var">e2</span> <span class="id" title="constructor">tt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The above definition may seem a bit peculiar.  What gave us the right to represent variables as <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span> values?  Recall that our final representation of closed terms is as polymorphic functions.  We merely specialize a closed term to exactly the right variable representation for the transformation we wish to perform. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.CountVars"><span class="id" title="definition">CountVars</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.countVars"><span class="id" title="definition">countVars</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">unit</span>)).<br/>

<br/>
</div>

<div class="doc">
It is easy to test that <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.CountVars"><span class="id" title="definition">CountVars</span></a></span> operates properly. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.CountVars"><span class="id" title="definition">CountVars</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 2
<div class="paragraph"> </div>

</span>     
<div class="paragraph"> </div>

 In fact, PHOAS can be used anywhere that first-order representations can.  We will not go into all the details here, but the intuition is that it is possible to interconvert between PHOAS and any reasonable first-order representation.  Here is a suggestive example, translating PHOAS terms into strings giving a first-order rendering.  To implement this translation, the key insight is to tag variables with strings, giving their names.  The function takes as an additional input a string giving the name to be assigned to the next variable introduced.  We evolve this name by adding a prime to its end.  To avoid getting bogged down in orthogonal details, we render all constants as the string <span class="inlinecode">&quot;<span class="id" title="var">N</span>&quot;</span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">String</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">string_scope</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">string</span>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) (<span class="id" title="var">x</span> : <span class="id" title="inductive">string</span>) : <span class="id" title="inductive">string</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="var">s</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> ⇒ "N"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ "(" <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> " + " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> ")"<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ "(fun " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> " =&gt; " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> (<span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> "'") <span class="id" title="notation">++</span> ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ "(" <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> " " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> ")"<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ "(let " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> " = " <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> <span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> " in "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">++</span> <a class="idref" href="Cpdt.ProgLang.html#pretty"><span class="id" title="definition">pretty</span></a> (<span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">++</span> "'") <span class="id" title="notation">++</span> ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Pretty"><span class="id" title="definition">Pretty</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.pretty"><span class="id" title="definition">pretty</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">string</span>)) "x".<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Pretty"><span class="id" title="definition">Pretty</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= "(((fun x =&gt; (fun x' =&gt; (x + x'))) N) N)"
<div class="paragraph"> </div>

</span>     
<div class="paragraph"> </div>

 However, it is not necessary to convert to first-order form to support many common operations on terms.  For instance, we can implement substitution of terms for variables.  The key insight here is to <i>tag variables with terms</i>, so that, on encountering a variable, we can simply replace it by the term in its tag.  We will call this function initially on a term with exactly one free variable, tagged with the appropriate substitute.  During recursion, new variables are added, but they are only tagged with their own term equivalents.  Note that this function <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.squash"><span class="id" title="definition">squash</span></a></span> is parameterized over a specific <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> choice. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">var</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <span class="id" title="var">e1</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> (<span class="id" title="var">e1</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> <span class="id" title="var">e1</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#squash"><span class="id" title="definition">squash</span></a> (<span class="id" title="var">e2</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
To define the final substitution function over terms with single free variables, we define <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term1"><span class="id" title="definition">Term1</span></a></span>, an analogue to <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a></span> that we defined before for closed terms. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Term1"><span class="id" title="definition">Term1</span></a> (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">var</span>, <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a>.<br/>

<br/>
</div>

<div class="doc">
Substitution is defined by (1) instantiating a <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term1"><span class="id" title="definition">Term1</span></a></span> to tag variables with terms and (2) applying the result to a specific term to be substituted. Note how the parameter <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.squash"><span class="id" title="definition">squash</span></a></span> is instantiated: the body of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Subst"><span class="id" title="definition">Subst</span></a></span> is itself a polymorphic quantification over <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span>, standing for a variable tag choice in the output term; and we use that input to compute a tag choice for the input term. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Subst"><span class="id" title="definition">Subst</span></a> (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term1"><span class="id" title="definition">Term1</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a>) (<span class="id" title="var">E'</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.squash"><span class="id" title="definition">squash</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#E'"><span class="id" title="variable">E'</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Subst"><span class="id" title="definition">Subst</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 3)) <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> → <span class="id" title="keyword">Type</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>)))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 3)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     One further development, which may seem surprising at first, is that we can also implement a usual term denotation function, when we <i>tag variables with their denotations</i>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">v</span> ⇒ <span class="id" title="var">v</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> (<span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> (<span class="id" title="var">e2</span> (<a class="idref" href="Cpdt.ProgLang.html#termDenote"><span class="id" title="definition">termDenote</span></a> <span class="id" title="var">e1</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 3
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   To summarize, the PHOAS representation has all the expressive power of more standard first-order encodings, and a variety of translations are actually much more pleasant to implement than usual, thanks to the novel ability to tag variables with data. 
<div class="paragraph"> </div>

<a name="lab97"></a><h2 class="section">Verifying Program Transformations</h2>

<div class="paragraph"> </div>

 Let us now revisit the three example program transformations from the last section.  Each is easy to implement with PHOAS, and the last is substantially easier than with first-order representations.

<div class="paragraph"> </div>

     First, we have the recursive identity function, following the same pattern as in the previous subsection, with a helper function, polymorphic in a tag choice; and a final function that instantiates the choice appropriately. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">var</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">x</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> (<span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> <span class="id" title="var">e1</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#ident"><span class="id" title="definition">ident</span></a> (<span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Ident"><span class="id" title="definition">Ident</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.ident"><span class="id" title="definition">ident</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>).<br/>

<br/>
</div>

<div class="doc">
Proving correctness is both easier and harder than in the last section, easier because we do not need to manipulate substitutions, and harder because we do the induction in an extra lemma about <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.ident"><span class="id" title="definition">ident</span></a></span>, to establish the correctness theorem for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Ident"><span class="id" title="definition">Ident</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="HigherOrder.identSound"><span class="id" title="lemma">identSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.ident"><span class="id" title="definition">ident</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="HigherOrder.IdentSound"><span class="id" title="lemma">IdentSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Ident"><span class="id" title="definition">Ident</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.identSound"><span class="id" title="lemma">identSound</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The translation of the constant-folding function and its proof work more or less the same way. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">var</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e1'</span> := <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e2'</span> := <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a>, <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n1</span>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> (<span class="id" title="var">n1</span> <span class="id" title="notation">+</span> <span class="id" title="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> (<span class="id" title="var">e1</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#cfold"><span class="id" title="definition">cfold</span></a> (<span class="id" title="var">e2</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>))<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">e</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Cfold"><span class="id" title="definition">Cfold</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="HigherOrder.cfoldSound"><span class="id" title="lemma">cfoldSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">pl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">pl</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="HigherOrder.CfoldSound"><span class="id" title="lemma">CfoldSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Cfold"><span class="id" title="definition">Cfold</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfoldSound"><span class="id" title="lemma">cfoldSound</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Things get more interesting in the <span class="inlinecode"><span class="id" title="keyword">Let</span></span>-removal optimization.  Our recursive helper function adapts the key idea from our earlier definitions of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.squash"><span class="id" title="definition">squash</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Subst"><span class="id" title="definition">Subst</span></a></span>: tag variables with terms.  We have a straightforward generalization of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.squash"><span class="id" title="definition">squash</span></a></span>, where only the <span class="inlinecode"><span class="id" title="keyword">Let</span></span> case has changed, to tag the new variable with the term it is bound to, rather than just tagging the variable with itself as a term. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="HigherOrder.unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">var</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <span class="id" title="var">e1</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> (<span class="id" title="var">e1</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Let</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> (<span class="id" title="var">e2</span> (<a class="idref" href="Cpdt.ProgLang.html#unlet"><span class="id" title="definition">unlet</span></a> <span class="id" title="var">e1</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">var</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var"><span class="id" title="variable">var</span></a>)).<br/>

<br/>
</div>

<div class="doc">
We can test <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span> first on an uninteresting example, <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a></span>, which does not use <span class="inlinecode"><span class="id" title="keyword">Let</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> → <span class="id" title="keyword">Type</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x0</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">x0</span>)))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     Next, we try a more interesting example, with some extra <span class="inlinecode"><span class="id" title="keyword">Let</span></span>s introduced in <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.three_a_harder_way"><span class="id" title="definition">three_a_harder_way</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">Let</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2) (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.add"><span class="id" title="definition">add</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#y"><span class="id" title="variable">y</span></a>))).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_a_harder_way"><span class="id" title="definition">three_a_harder_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> → <span class="id" title="keyword">Type</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x0</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">x0</span>)))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 1)) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> 2)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     The output is the same as in the previous test, confirming that <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span> operates properly here.

<div class="paragraph"> </div>

     Now we need to state a correctness theorem for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span>, based on an inductively proved lemma about <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span>.  It is not at all obvious how to arrive at a proper induction principle for the lemma.  The problem is that we want to relate two instantiations of the same <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a></span>, in a way where we know they share the same structure.  Note that, while <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span> is defined to consider all possible <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> choices in the output term, the correctness proof conveniently only depends on the case of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span>.  Thus, one parallel instantiation will set <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span>, to take the denotation of the original term.  The other parallel instantiation will set <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span>, to perform the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span> transformation in the original term.

<div class="paragraph"> </div>

     Here is a relation formalizing the idea that two terms are structurally the same, differing only by replacing the variable data of one with another isomorphic set of variable data in some possibly different type family. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <span class="id" title="keyword">wf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="HigherOrder.wf.var1"><span class="id" title="variable">var1</span></a> <a name="HigherOrder.wf.var2"><span class="id" title="variable">var2</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
To formalize the tag isomorphism, we will use lists of values with the following record type.  Each entry has an object language type and an appropriate tag for that type, in each of the two tag families <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var1"><span class="id" title="variable">var1</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var2"><span class="id" title="variable">var2</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Record</span> <a name="HigherOrder.varEntry"><span class="id" title="record">varEntry</span></a> := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="HigherOrder.Ty"><span class="id" title="projection">Ty</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="HigherOrder.First"><span class="id" title="projection">First</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var1"><span class="id" title="variable">var1</span></a> <a class="idref" href="Cpdt.ProgLang.html#Ty"><span class="id" title="method">Ty</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="HigherOrder.Second"><span class="id" title="projection">Second</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var2"><span class="id" title="variable">var2</span></a> <a class="idref" href="Cpdt.ProgLang.html#Ty"><span class="id" title="method">Ty</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
Here is the inductive relation definition.  An instance <span class="inlinecode"><span class="id" title="keyword">wf</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a></span> asserts that terms <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a></span> are equivalent up to the variable tag isomorphism <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span>.  Note how the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a></span> rule looks up an entry in <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span>, and the <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a></span> and <span class="inlinecode"><span class="id" title="keyword">Let</span></span> rules include recursive <span class="inlinecode"><span class="id" title="keyword">wf</span></span> invocations inside the scopes of quantifiers to introduce parallel tag values to be considered as isomorphic. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="keyword">wf</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.varEntry"><span class="id" title="record">varEntry</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var1"><span class="id" title="variable">var1</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.wf.var2"><span class="id" title="variable">var2</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfVar"><span class="id" title="constructor">WfVar</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> <span class="id" title="var">x</span> <span class="id" title="var">x'</span>, <span class="id" title="definition">In</span> {| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">Ty</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">t</span></a><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">;</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">First</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x</span></a><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">;</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">Second</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x'</span></a> |} <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a> <a class="idref" href="Cpdt.ProgLang.html#x'"><span class="id" title="variable">x'</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfConst"><span class="id" title="constructor">WfConst</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">n</span>, <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.ProgLang.html#n"><span class="id" title="variable">n</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfPlus"><span class="id" title="constructor">WfPlus</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">e1'</span> <span class="id" title="var">e2'</span>, <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfAbs"><span class="id" title="constructor">WfAbs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span> (<span class="id" title="var">e1</span> : <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>) <span class="id" title="var">e1'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x1</span> <span class="id" title="var">x2</span>, <span class="id" title="keyword">wf</span> (<span class="id" title="notation">{|</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">First</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x1</span></a><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">;</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">Second</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x2</span></a> <span class="id" title="notation">|}</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#x1"><span class="id" title="variable">x1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#x2"><span class="id" title="variable">x2</span></a>)<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfApp"><span class="id" title="constructor">WfApp</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">dom</span> <span class="id" title="var">ran</span> (<span class="id" title="var">e1</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a> <a class="idref" href="Cpdt.ProgLang.html#ran"><span class="id" title="variable">ran</span></a>)) (<span class="id" title="var">e2</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#dom"><span class="id" title="variable">dom</span></a>) <span class="id" title="var">e1'</span> <span class="id" title="var">e2'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="HigherOrder.WfLet"><span class="id" title="constructor">WfLet</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">e1</span> <span class="id" title="var">e1'</span> (<span class="id" title="var">e2</span> : <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#t2"><span class="id" title="variable">t2</span></a>) <span class="id" title="var">e2'</span>, <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x1</span> <span class="id" title="var">x2</span>, <span class="id" title="keyword">wf</span> (<span class="id" title="notation">{|</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">First</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x1</span></a><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">;</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">Second</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">:=</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Build_varEntry"><span class="id" title="constructor">x2</span></a> <span class="id" title="notation">|}</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Cpdt.ProgLang.html#x1"><span class="id" title="variable">x1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a> <a class="idref" href="Cpdt.ProgLang.html#x2"><span class="id" title="variable">x2</span></a>)<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> (<span class="id" title="keyword">Let</span> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>) (<span class="id" title="keyword">Let</span> <a class="idref" href="Cpdt.ProgLang.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2'"><span class="id" title="variable">e2'</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <span class="id" title="keyword">wf</span>.<br/>

<br/>
</div>

<div class="doc">
We can state a well-formedness condition for closed terms: for any two choices of tag type families, the parallel instantiations belong to the <span class="inlinecode"><span class="id" title="keyword">wf</span></span> relation, starting from an empty variable isomorphism. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="HigherOrder.Wf"><span class="id" title="definition">Wf</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">var1</span> <span class="id" title="var">var2</span>, <span class="id" title="keyword">wf</span> <span class="id" title="constructor">nil</span> (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Cpdt.ProgLang.html#var1"><span class="id" title="variable">var1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Cpdt.ProgLang.html#var2"><span class="id" title="variable">var2</span></a>).<br/>

<br/>
</div>

<div class="doc">
After digesting the syntactic details of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span>, it is probably not hard to see that reasonable term encodings will satisfy it.  For example: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="HigherOrder.three_the_hard_way_Wf"><span class="id" title="lemma">three_the_hard_way_Wf</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.three_the_hard_way"><span class="id" title="definition">three_the_hard_way</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">intros</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we are ready to give a nice simple proof of correctness for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span>.  First, we add one hint to apply a small variant of a standard library theorem connecting <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall"><span class="id" title="section">Forall</span></a></span>, a higher-order predicate asserting that every element of a list satisfies some property; and <span class="inlinecode"><span class="id" title="definition">In</span></span>, the list membership predicate. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 ⇒ <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H1</span> : <span class="id" title="inductive">Forall</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>, <span class="id" title="var">H2</span> : <span class="id" title="definition">In</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall_In"><span class="id" title="lemma">Forall_In</span></a> <span class="id" title="var">H1</span> <span class="id" title="var">_</span> <span class="id" title="var">H2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The rest of the proof is about as automated as we could hope for. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="HigherOrder.unletSound"><span class="id" title="lemma">unletSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e1</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">e2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="inductive">Forall</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">ve</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.First"><span class="id" title="projection">First</span></a> <a class="idref" href="Cpdt.ProgLang.html#ve"><span class="id" title="variable">ve</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Second"><span class="id" title="projection">Second</span></a> <a class="idref" href="Cpdt.ProgLang.html#ve"><span class="id" title="variable">ve</span></a>) <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.termDenote"><span class="id" title="definition">termDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">pl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="HigherOrder.UnletSound"><span class="id" title="lemma">UnletSound</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>), <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unletSound"><span class="id" title="lemma">unletSound</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
With this example, it is not obvious that the PHOAS encoding is more tractable than dependent de Bruijn.  Where the de Bruijn version had <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a></span> and its helper functions, here we have <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span> and its auxiliary definitions.  In practice, <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span> is defined once per object language, while such operations as <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#FirstOrder.lift"><span class="id" title="definition">lift</span></a></span> often need to operate differently for different examples, forcing new implementations for new transformations.

<div class="paragraph"> </div>

     The reader may also have come up with another objection: via Curry-Howard, <span class="inlinecode"><span class="id" title="keyword">wf</span></span> proofs may be thought of as first-order encodings of term syntax!  For instance, the <span class="inlinecode"><span class="id" title="definition">In</span></span> hypothesis of rule <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.WfVar"><span class="id" title="constructor">WfVar</span></a></span> is equivalent to a <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#member"><span class="id" title="inductive">member</span></a></span> value.  There is some merit to this objection.  However, as the proofs above show, we are able to reason about transformations using first-order representation only for their inputs, not their outputs.  Furthermore, explicit numbering of variables remains absent from the proofs.

<div class="paragraph"> </div>

     Have we really avoided first-order reasoning about the output terms of translations?  The answer depends on some subtle issues, which deserve a subsection of their own. 
<div class="paragraph"> </div>

<a name="lab98"></a><h2 class="section">Establishing Term Well-Formedness</h2>

<div class="paragraph"> </div>

 Can there be values of type <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> that are not well-formed according to <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span>?  We expect that Gallina satisfies key <i>parametricity</i>  properties, which indicate how polymorphic types may only be inhabited by specific values.  We omit details of parametricity theorems here, but <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>),</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> follows the flavor of such theorems.  One option would be to assert that fact as an axiom, "proving" that any output of any of our translations is well-formed.  We could even prove the soundness of the theorem on paper meta-theoretically, say by considering some particular model of CIC.

<div class="paragraph"> </div>

     To be more cautious, we could prove <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span> for every term that interests us, threading such proofs through all transformations.  Here is an example exercise of that kind, for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span>.

<div class="paragraph"> </div>

     First, we prove that <span class="inlinecode"><span class="id" title="keyword">wf</span></span> is <i>monotone</i>, in that a given instance continues to hold as we add new variable pairs to the variable isomorphism. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="keyword">wf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="definition">In</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="inductive">Forall</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">eapply</span> <a class="idref" href="Cpdt.ProgLang.html#Forall_weaken"><span class="id" title="lemma">Forall_weaken</span></a>; [ <span class="id" title="var">eassumption</span> | <span class="id" title="tactic">simpl</span> ].<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="HigherOrder.wf_monotone"><span class="id" title="lemma">wf_monotone</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">var1</span> <span class="id" title="var">var2</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e1</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var1"><span class="id" title="variable">var1</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) (<span class="id" title="var">e2</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var2"><span class="id" title="variable">var2</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">G'</span>, <span class="id" title="inductive">Forall</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="definition">In</span> <a class="idref" href="Cpdt.ProgLang.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a>) <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">pl</span>; <span class="id" title="tactic">auto</span> 6.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">wf_monotone</span> <span class="id" title="var">Forall_In'</span>.<br/>

<br/>
</div>

<div class="doc">
Now we are ready to prove that <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span> preserves any <span class="inlinecode"><span class="id" title="keyword">wf</span></span> instance.  The key invariant has to do with the parallel execution of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span> on two different <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.var.var"><span class="id" title="variable">var</span></a></span> instantiations of a particular term.  Since <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a></span> uses <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span> as the type of variable data, our variable isomorphism context <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> contains pairs of terms, which, conveniently enough, allows us to state the invariant that any pair of terms in the context is also related by <span class="inlinecode"><span class="id" title="keyword">wf</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">progress</span> <span class="id" title="tactic">simpl</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="HigherOrder.unletWf"><span class="id" title="lemma">unletWf</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">var1</span> <span class="id" title="var">var2</span> <span class="id" title="var">G</span> <span class="id" title="var">t</span> (<span class="id" title="var">e1</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var1"><span class="id" title="variable">var1</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>) (<span class="id" title="var">e2</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a> <a class="idref" href="Cpdt.ProgLang.html#var2"><span class="id" title="variable">var2</span></a>) <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">G'</span>, <span class="id" title="inductive">Forall</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">ve</span> ⇒ <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.First"><span class="id" title="projection">First</span></a> <a class="idref" href="Cpdt.ProgLang.html#ve"><span class="id" title="variable">ve</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Second"><span class="id" title="projection">Second</span></a> <a class="idref" href="Cpdt.ProgLang.html#ve"><span class="id" title="variable">ve</span></a>)) <a class="idref" href="Cpdt.ProgLang.html#G"><span class="id" title="variable">G</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="keyword">wf</span> <a class="idref" href="Cpdt.ProgLang.html#G'"><span class="id" title="variable">G'</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unlet"><span class="id" title="definition">unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#e2"><span class="id" title="variable">e2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">pl</span>; <span class="id" title="tactic">eauto</span> 9.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Repackaging <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unletWf"><span class="id" title="lemma">unletWf</span></a></span> into a theorem about <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a></span> is straightforward. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="HigherOrder.UnletWf"><span class="id" title="lemma">UnletWf</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">E</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#t"><span class="id" title="variable">t</span></a>), <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Wf"><span class="id" title="definition">Wf</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Unlet"><span class="id" title="definition">Unlet</span></a> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.unletWf"><span class="id" title="lemma">unletWf</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">nil</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This example demonstrates how we may need to use reasoning reminiscent of that associated with first-order representations, though the bookkeeping details are generally easier to manage, and bookkeeping theorems may generally be proved separately from the independently interesting theorems about program transformations. 
<div class="paragraph"> </div>

<a name="lab99"></a><h2 class="section">A Few More Remarks</h2>

<div class="paragraph"> </div>

 Higher-order encodings derive their strength from reuse of the meta language's binding constructs.  As a result, we can write encoded terms so that they look very similar to their informal counterparts, without variable numbering schemes like for de Bruijn indices.  The example encodings above have demonstrated this fact, but modulo the clunkiness of explicit use of the constructors of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.term"><span class="id" title="inductive">term</span></a></span>.  After defining a few new Coq syntax notations, we can work with terms in an even more standard form. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Infix</span> <a name="4051e25caf67b9371211abf303e38c0f"><span class="id" title="notation">&quot;</span></a>--&gt;" := <a class="idref" href="Cpdt.ProgLang.html#Func"><span class="id" title="constructor">Func</span></a> (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 52).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a name="634af7ac0b0e292d11b49be32712d30b"><span class="id" title="notation">&quot;</span></a>^" := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Var"><span class="id" title="constructor">Var</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a name="556e301b640dd3e4df0f20ff46ff8fb7"><span class="id" title="notation">&quot;</span></a>#" := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Infix</span> <a name="a4934b8b3a553d98b816ddfda68b1140"><span class="id" title="notation">&quot;</span></a>@" := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.App"><span class="id" title="constructor">App</span></a> (<span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Infix</span> <a name="519999f44801f843b8786c2e3709a868"><span class="id" title="notation">&quot;</span></a>@+" := <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a name="4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">&quot;</span></a>\ x : t , e" := (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Abs"><span class="id" title="constructor">Abs</span></a> (<span class="id" title="var">dom</span> := <span class="id" title="var">t</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">e</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 51, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> <a name="b1ab69c9794639c53ff0006d386f3ae3"><span class="id" title="notation">&quot;</span></a>[ e ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">e</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <span class="id" title="keyword">Add</span> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.ProgLang.html#4051e25caf67b9371211abf303e38c0f"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.ProgLang.html#4051e25caf67b9371211abf303e38c0f"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#b1ab69c9794639c53ff0006d386f3ae3"><span class="id" title="notation">[</span></a><a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">\</span></a><span class="id" title="var">x</span> <a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">:</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">,</span></a> <a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">\</span></a><span class="id" title="var">y</span> <a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">:</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a><a class="idref" href="Cpdt.ProgLang.html#4631b2909f6a3c8e70c5b21cb15b5c37"><span class="id" title="notation">,</span></a> <a class="idref" href="Cpdt.ProgLang.html#634af7ac0b0e292d11b49be32712d30b"><span class="id" title="notation">^</span></a><span class="id" title="var">x</span> <a class="idref" href="Cpdt.ProgLang.html#519999f44801f843b8786c2e3709a868"><span class="id" title="notation">@+</span></a> <a class="idref" href="Cpdt.ProgLang.html#634af7ac0b0e292d11b49be32712d30b"><span class="id" title="notation">^</span></a><span class="id" title="var">y</span><a class="idref" href="Cpdt.ProgLang.html#b1ab69c9794639c53ff0006d386f3ae3"><span class="id" title="notation">]</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Example</span> <a name="HigherOrder.Three_the_hard_way"><span class="id" title="definition">Three_the_hard_way</span></a> : <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Term"><span class="id" title="definition">Term</span></a> <a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#b1ab69c9794639c53ff0006d386f3ae3"><span class="id" title="notation">[</span></a><span class="id" title="keyword">Add</span> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.ProgLang.html#a4934b8b3a553d98b816ddfda68b1140"><span class="id" title="notation">@</span></a> <a class="idref" href="Cpdt.ProgLang.html#556e301b640dd3e4df0f20ff46ff8fb7"><span class="id" title="notation">#</span></a>1 <a class="idref" href="Cpdt.ProgLang.html#a4934b8b3a553d98b816ddfda68b1140"><span class="id" title="notation">@</span></a> <a class="idref" href="Cpdt.ProgLang.html#556e301b640dd3e4df0f20ff46ff8fb7"><span class="id" title="notation">#</span></a>2<a class="idref" href="Cpdt.ProgLang.html#b1ab69c9794639c53ff0006d386f3ae3"><span class="id" title="notation">]</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.TermDenote"><span class="id" title="definition">TermDenote</span></a> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Three_the_hard_way"><span class="id" title="definition">Three_the_hard_way</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 3
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder"><span class="id" title="module">HigherOrder</span></a>.<br/>

<br/>
</div>

<div class="doc">
The PHOAS approach shines here because we are working with an object language that has an easy embedding into Coq.  That is, there is a straightforward recursive function translating object terms into terms of Gallina.  All Gallina programs terminate, so clearly we cannot hope to find such embeddings for Turing-complete languages; and non-Turing-complete languages may still require much more involved translations.  I have some work on modeling semantics of Turing-complete languages with PHOAS, but my impression is that there are many more advances left to be made in this field, possibly with completely new term representations that we have not yet been clever enough to think up. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>