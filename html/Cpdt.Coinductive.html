<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.Coinductive</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.Coinductive</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 In lazy functional programming languages like Haskell, infinite data structures are everywhere.  Infinite lists and more exotic datatypes provide convenient abstractions for communication between parts of a program.  Achieving similar convenience without infinite lazy structures would, in many cases, require acrobatic inversions of control flow.

<div class="paragraph"> </div>

Laziness is easy to implement in Haskell, where all the definitions in a program may be thought of as mutually recursive.  In such an unconstrained setting, it is easy to implement an infinite loop when you really meant to build an infinite list, where any finite prefix of the list should be forceable in finite time.  Haskell programmers learn how to avoid such slip-ups.  In Coq, such a laissez-faire policy is not good enough.

<div class="paragraph"> </div>

We spent some time in the last chapter discussing the Curry-Howard isomorphism, where proofs are identified with functional programs.  In such a setting, infinite loops, intended or otherwise, are disastrous.  If Coq allowed the full breadth of definitions that Haskell did, we could code up an infinite loop and use it to prove any proposition vacuously.  That is, the addition of general recursion would make CIC <i>inconsistent</i>.  For an arbitrary proposition <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>, we could write:
<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a> (<a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> : <a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a>) : <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> := <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This would leave us with <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a></span> as a proof of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>.

<div class="paragraph"> </div>

There are also algorithmic considerations that make universal termination very desirable.  We have seen how tactics like <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> compare terms up to equivalence under computational rules.  Calls to recursive, pattern-matching functions are simplified automatically, with no need for explicit proof steps.  It would be very hard to hold onto that kind of benefit if it became possible to write non-terminating programs; we would be running smack into the halting problem.

<div class="paragraph"> </div>

One solution is to use types to contain the possibility of non-termination.  For instance, we can create a "non-termination monad," inside which we must write all of our general-recursive programs; several such approaches are surveyed in Chapter 7.  This is a heavyweight solution, and so we would like to avoid it whenever possible.

<div class="paragraph"> </div>

Luckily, Coq has special support for a class of lazy data structures that happens to contain most examples found in Haskell.  That mechanism, <i>co-inductive types</i>, is the subject of this chapter. 
<div class="paragraph"> </div>

<a name="lab39"></a><h1 class="section">Computing with Infinite Data</h1>

<div class="paragraph"> </div>

 Let us begin with the most basic type of infinite data, <i>streams</i>, or lazy lists. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="stream"><span class="id" title="section">stream</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="stream.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">CoInductive</span> <a name="stream"><span class="id" title="inductive">stream</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Cons"><span class="id" title="constructor">Cons</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="section">stream</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
The definition is surprisingly simple.  Starting from the definition of <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a></span>, we just need to change the keyword <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> to <span class="inlinecode"><span class="id" title="keyword">CoInductive</span></span>.  We could have left a <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Nil"><span class="id" title="constructor">Nil</span></a></span> constructor in our definition, but we will leave it out to force all of our streams to be infinite.

<div class="paragraph"> </div>

   How do we write down a stream constant?  Obviously, simple application of constructors is not good enough, since we could only denote finite objects that way.  Rather, whereas recursive definitions were necessary to <i>use</i> values of recursive inductive types effectively, here we find that we need <i>co-recursive definitions</i> to <i>build</i> values of co-inductive types effectively.

<div class="paragraph"> </div>

   We can define a stream consisting only of zeroes. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <a name="zeroes"><span class="id" title="definition">zeroes</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <span class="id" title="inductive">nat</span> := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> 0 <a class="idref" href="Cpdt.Coinductive.html#zeroes"><span class="id" title="definition">zeroes</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
We can also define a stream that alternates between <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <a name="trues_falses"><span class="id" title="definition">trues_falses</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <span class="id" title="inductive">bool</span> := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="constructor">true</span> <a class="idref" href="Cpdt.Coinductive.html#falses_trues"><span class="id" title="definition">falses_trues</span></a><br/>
<span class="id" title="keyword">with</span> <a name="falses_trues"><span class="id" title="definition">falses_trues</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <span class="id" title="inductive">bool</span> := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="constructor">false</span> <a class="idref" href="Cpdt.Coinductive.html#trues_falses"><span class="id" title="definition">trues_falses</span></a>.<br/>

<br/>
</div>

<div class="doc">
Co-inductive values are fair game as arguments to recursive functions, and we can use that fact to write a function to take a finite approximation of a stream. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="approx"><span class="id" title="definition">approx</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a> <span class="id" title="var">t</span> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a> <a class="idref" href="Cpdt.Coinductive.html#zeroes"><span class="id" title="definition">zeroes</span></a> 10.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0 :: 0 :: 0 :: 0 :: 0 :: 0 :: 0 :: 0 :: 0 :: 0 :: <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a> <a class="idref" href="Cpdt.Coinductive.html#trues_falses"><span class="id" title="definition">trues_falses</span></a> 10.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a> :: <a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a> :: <a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a> :: <a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a> :: <a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a> :: <a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a> :: <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.Predicates.html#bool"><span class="id" title="inductive">bool</span></a>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
So far, it looks like co-inductive types might be a magic bullet, allowing us to import all of the Haskeller's usual tricks.  However, there are important restrictions that are dual to the restrictions on the use of inductive types.  Fixpoints <i>consume</i> values of inductive types, with restrictions on which <i>arguments</i> may be passed in recursive calls.  Dually, co-fixpoints <i>produce</i> values of co-inductive types, with restrictions on what may be done with the <i>results</i> of co-recursive calls.

<div class="paragraph"> </div>

The restriction for co-inductive types shows up as the <i>guardedness condition</i>.  First, consider this stream definition, which would be legal in Haskell.
<br/>
<span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span> <a class="idref" href="Cpdt.GeneralRec.html#looper"><span class="id" title="definition">looper</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> := <a class="idref" href="Cpdt.GeneralRec.html#looper"><span class="id" title="definition">looper</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error:
Recursive definition of looper is ill-formed.
In environment
looper : stream nat

unguarded recursive call in "looper"
</pre>

<div class="paragraph"> </div>

The rule we have run afoul of here is that <i>every co-recursive call must be guarded by a constructor</i>; that is, every co-recursive call must be a direct argument to a constructor of the co-inductive type we are generating.  It is a good thing that this rule is enforced.  If the definition of <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#looper"><span class="id" title="definition">looper</span></a></span> were accepted, our <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a></span> function would run forever when passed <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#looper"><span class="id" title="definition">looper</span></a></span>, and we would have fallen into inconsistency.

<div class="paragraph"> </div>

Some familiar functions are easy to write in co-recursive fashion. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="map"><span class="id" title="section">map</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="map.A"><span class="id" title="variable">A</span></a> <a name="map.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="map.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Coinductive.html#map.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#map.B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">CoFixpoint</span> <a name="map"><span class="id" title="definition">map</span></a> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#map.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#map.B"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Coinductive.html#map.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">h</span>) (<a class="idref" href="Cpdt.Coinductive.html#map"><span class="id" title="definition">map</span></a> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#map"><span class="id" title="section">map</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
This code is a literal copy of that for the list <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a></span> function, with the <span class="inlinecode"><span class="id" title="constructor">nil</span></span> case removed and <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> changed to <span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span></span>.  Many other standard functions on lazy data structures can be implemented just as easily.  Some, like <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#filter"><span class="id" title="definition">filter</span></a></span>, cannot be implemented.  Since the predicate passed to <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#filter"><span class="id" title="definition">filter</span></a></span> may reject every element of the stream, we cannot satisfy the guardedness condition.

<div class="paragraph"> </div>

   The implications of the condition can be subtle.  To illustrate how, we start off with another co-recursive function definition that <i>is</i> legal.  The function <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a></span> takes two streams and produces a new stream that alternates between their elements. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="interleave"><span class="id" title="section">interleave</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="interleave.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">CoFixpoint</span> <a name="interleave"><span class="id" title="definition">interleave</span></a> (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#interleave.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#interleave.A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a>, <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h1</span> <span class="id" title="var">t1</span>, <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h2</span> <span class="id" title="var">t2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h1</span> (<a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h2</span> (<a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="section">interleave</span></a>.<br/>

<br/>
</div>

<div class="doc">
Now say we want to write a weird stuttering version of <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a></span> that repeats elements in a particular way, based on interleaving. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="map'"><span class="id" title="section">map'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="map'.A"><span class="id" title="variable">A</span></a> <a name="map'.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="map'.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Coinductive.html#map'.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#map'.B"><span class="id" title="variable">B</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">CoFixpoint</span> <a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> ⇒ <a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a> (<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>)) (<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>    We get another error message about an unguarded recursive call. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#map'"><span class="id" title="section">map'</span></a>.<br/>

<br/>
</div>

<div class="doc">
What is going wrong here?  Imagine that, instead of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a></span>, we had called some other, less well-behaved function on streams.  Here is one simpler example demonstrating the essential pitfall.  We start by defining a standard function for taking the tail of a stream.  Since streams are infinite, this operation is total. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tl"><span class="id" title="definition">tl</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">s'</span> ⇒ <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq rejects the following definition that uses <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a></span>.
<br/>
<span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span> <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> := <a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> (<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> 0 <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Imagine that Coq had accepted our definition, and consider how we might evaluate <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span> <span class="inlinecode">1</span>.  We would be trying to calculate the first element in the stream <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span>.  However, it is not hard to see that the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span> "begs the question": unfolding the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a></span>, we see that we essentially say "define <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span> to equal itself"!  Of course such an equation admits no single well-defined solution, which does not fit well with the determinism of Gallina reduction.

<div class="paragraph"> </div>

Coq's complete rule for co-recursive definitions includes not just the basic guardedness condition, but also a requirement about where co-recursive calls may occur.  In particular, a co-recursive call must be a direct argument to a constructor, <i>nested only inside of other constructor calls or <span class="inlinecode"><span class="id" title="keyword">fun</span></span> or <span class="inlinecode"><span class="id" title="keyword">match</span></span> expressions</i>.  In the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span>, we erroneously nested the co-recursive call inside a call to <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a></span>, and we nested inside a call to <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a></span> in the definition of <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a></span>.

<div class="paragraph"> </div>

Coq helps the user out a little by performing the guardedness check after using computation to simplify terms.  For instance, any co-recursive function definition can be expanded by inserting extra calls to an identity function, and this change preserves guardedness.  However, in other cases computational simplification can reveal why definitions are dangerous.  Consider what happens when we inline the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a></span> in <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a></span>:
<br/>
<span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span> <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> := <a class="idref" href="Cpdt.Coinductive.html#bad"><span class="id" title="definition">bad</span></a>.
<div class="paragraph"> </div>

</span>This is the same looping definition we rejected earlier.  A similar inlining process reveals an alternate view on our failed definition of <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a></span>:
<br/>
<span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span> <a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> ⇒ <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#interleave"><span class="id" title="definition">interleave</span></a> (<a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>)))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>Clearly in this case the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a></span> calls are not immediate arguments to constructors, so we violate the guardedness condition. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
A more interesting question is why that condition is the right one.  We can make an intuitive argument that the original <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#map'"><span class="id" title="definition">map'</span></a></span> definition is perfectly reasonable and denotes a well-understood transformation on streams, such that every output would behave properly with <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a></span>.  The guardedness condition is an example of a syntactic check for <i>productivity</i> of co-recursive definitions.  A productive definition can be thought of as one whose outputs can be forced in finite time to any finite approximation level, as with <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a></span>.  If we replaced the guardedness condition with more involved checks, we might be able to detect and allow a broader range of productive definitions.  However, mistakes in these checks could cause inconsistency, and programmers would need to understand the new, more complex checks.  Coq's design strikes a balance between consistency and simplicity with its choice of guard condition, though we can imagine other worthwhile balances being struck, too. 
<div class="paragraph"> </div>

<a name="lab40"></a><h1 class="section">Infinite Proofs</h1>

<div class="paragraph"> </div>

 Let us say we want to give two different definitions of a stream of all ones, and then we want to prove that they are equivalent. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <a name="ones"><span class="id" title="definition">ones</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <span class="id" title="inductive">nat</span> := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> 1 <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="ones'"><span class="id" title="definition">ones'</span></a> := <a class="idref" href="Cpdt.Coinductive.html#map"><span class="id" title="definition">map</span></a> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#zeroes"><span class="id" title="definition">zeroes</span></a>.<br/>

<br/>
</div>

<div class="doc">
The obvious statement of the equality is this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
However, faced with the initial subgoal, it is not at all clear how this theorem can be proved.  In fact, it is unprovable.  The <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> predicate that we use is fundamentally limited to equalities that can be demonstrated by finite, syntactic arguments.  To prove this equivalence, we will need to introduce a new relation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Co-inductive datatypes make sense by analogy from Haskell.  What we need now is a <i>co-inductive proposition</i>.  That is, we want to define a proposition whose proofs may be infinite, subject to the guardedness condition.  The idea of infinite proofs does not show up in usual mathematics, but it can be very useful (unsurprisingly) for reasoning about infinite data structures.  Besides examples from Haskell, infinite data and proofs will also turn out to be useful for modelling inherently infinite mathematical objects, like program executions.

<div class="paragraph"> </div>

We are ready for our first co-inductive predicate. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="stream_eq"><span class="id" title="section">stream_eq</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="stream_eq.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">CoInductive</span> <a name="stream_eq"><span class="id" title="inductive">stream_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Stream_eq"><span class="id" title="constructor">Stream_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.Coinductive.html#t2"><span class="id" title="variable">t2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.Coinductive.html#t1"><span class="id" title="variable">t1</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.Coinductive.html#t2"><span class="id" title="variable">t2</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="section">stream_eq</span></a>.<br/>

<br/>
</div>

<div class="doc">
We say that two streams are equal if and only if they have the same heads and their tails are equal.  We use the normal finite-syntactic equality for the heads, and we refer to our new equality recursively for the tails.

<div class="paragraph"> </div>

We can try restating the theorem with <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>
</div>

<div class="doc">
Coq does not support tactical co-inductive proofs as well as it supports tactical inductive proofs.  The usual starting point is the <span class="inlinecode"><span class="id" title="keyword">cofix</span></span> tactic, which asks to structure this proof as a co-fixpoint. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">cofix</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   It looks like this proof might be easier than we expected! 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
</div>

<div class="doc">
<pre>
Proof completed.
</pre>

<div class="paragraph"> </div>

  Unfortunately, we are due for some disappointment in our victory lap.
  <br/>
<span class="inlinecode"><span class="id" title="keyword">Qed</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error:
Recursive definition of ones_eq is ill-formed.

In environment
ones_eq : stream_eq ones ones'

unguarded recursive call in "ones_eq"
</pre>

<div class="paragraph"> </div>

Via the Curry-Howard correspondence, the same guardedness condition applies to our co-inductive proofs as to our co-inductive data structures.  We should be grateful that this proof is rejected, because, if it were not, the same proof structure could be used to prove any co-inductive theorem vacuously, by direct appeal to itself!

<div class="paragraph"> </div>

Thinking about how Coq would generate a proof term from the proof script above, we see that the problem is that we are violating the guardedness condition.  During our proofs, Coq can help us check whether we have yet gone wrong in this way.  We can run the command <span class="inlinecode"><span class="id" title="keyword">Guarded</span></span> in any context to see if it is possible to finish the proof in a way that will yield a properly guarded proof term.
     <br/>
<span class="inlinecode"><span class="id" title="keyword">Guarded</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     Running <span class="inlinecode"><span class="id" title="keyword">Guarded</span></span> here gives us the same error message that we got when we tried to run <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>.  In larger proofs, <span class="inlinecode"><span class="id" title="keyword">Guarded</span></span> can be helpful in detecting problems <i>before</i> we think we are ready to run <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>.

<div class="paragraph"> </div>

     We need to start the co-induction by applying <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a></span>'s constructor.  To do that, we need to know that both arguments to the predicate are <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a></span>es.  Informally, this is trivial, but <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> is not able to help us. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   It turns out that we are best served by proving an auxiliary lemma. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
First, we need to define a function that seems pointless at first glance. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="frob"><span class="id" title="definition">frob</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Next, we need to prove a theorem that seems equally pointless. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="frob_eq"><span class="id" title="lemma">frob_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#frob"><span class="id" title="definition">frob</span></a> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
But, miraculously, this theorem turns out to be just what we needed. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">cofix</span>.<br/>

<br/>
</div>

<div class="doc">
We can use the theorem to rewrite the two streams. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.Coinductive.html#frob_eq"><span class="id" title="lemma">frob_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.Coinductive.html#frob_eq"><span class="id" title="lemma">frob_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.GeneralRec.html#frob"><span class="id" title="definition">frob</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a>) (<a class="idref" href="Cpdt.GeneralRec.html#frob"><span class="id" title="definition">frob</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>)<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   Now <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> is able to reduce the streams. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> 1 <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="keyword">cofix</span> <a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> ⇒ <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.Coinductive.html#zeroes"><span class="id" title="definition">zeroes</span></a>))<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  Note the <span class="inlinecode"><span class="id" title="keyword">cofix</span></span> notation for anonymous co-recursion, which is analogous to the <span class="inlinecode"><span class="id" title="keyword">fix</span></span> notation we have already seen for recursion.  Since we have exposed the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a></span> structure of each stream, we can apply the constructor of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#ones_eq"><span class="id" title="lemma">ones_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="keyword">cofix</span> <a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> ⇒ <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.Coinductive.html#zeroes"><span class="id" title="definition">zeroes</span></a>)<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  Now, modulo unfolding of the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a></span>, we have matched our assumption. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Why did this silly-looking trick help?  The answer has to do with the constraints placed on Coq's evaluation rules by the need for termination.  The <span class="inlinecode"><span class="id" title="keyword">cofix</span></span>-related restriction that foiled our first attempt at using <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> is dual to a restriction for <span class="inlinecode"><span class="id" title="keyword">fix</span></span>.  In particular, an application of an anonymous <span class="inlinecode"><span class="id" title="keyword">fix</span></span> only reduces when the top-level structure of the recursive argument is known.  Otherwise, we would be unfolding the recursive definition ad infinitum.

<div class="paragraph"> </div>

   Fixpoints only reduce when enough is known about the <i>definitions</i> of their arguments.  Dually, co-fixpoints only reduce when enough is known about <i>how their results will be used</i>.  In particular, a <span class="inlinecode"><span class="id" title="keyword">cofix</span></span> is only expanded when it is the discriminee of a <span class="inlinecode"><span class="id" title="keyword">match</span></span>.  Rewriting with our superficially silly lemma wrapped new <span class="inlinecode"><span class="id" title="keyword">match</span></span>es around the two <span class="inlinecode"><span class="id" title="keyword">cofix</span></span>es, triggering reduction.

<div class="paragraph"> </div>

   If <span class="inlinecode"><span class="id" title="keyword">cofix</span></span>es reduced haphazardly, it would be easy to run into infinite loops in evaluation, since we are, after all, building infinite objects.

<div class="paragraph"> </div>

   One common source of difficulty with co-inductive proofs is bad interaction with standard Coq automation machinery.  If we try to prove <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#ones_eq'"><span class="id" title="lemma">ones_eq'</span></a></span> with automation, like we have in previous inductive proofs, we get an invalid proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq'"><span class="id" title="lemma">ones_eq'</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">cofix</span>; <span class="id" title="var">crush</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Guarded</span>.<br/>
&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>  
  
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The standard <span class="inlinecode"><span class="id" title="tactic">auto</span></span> machinery sees that our goal matches an assumption and so applies that assumption, even though this violates guardedness.  A correct proof strategy for a theorem like this usually starts by <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>ing some parameter and running a custom tactic to figure out the first proof rule to apply for each case.  Alternatively, there are tricks that can be played with "hiding" the co-inductive hypothesis.

<div class="paragraph"> </div>

   

<div class="paragraph"> </div>

   Must we always be cautious with automation in proofs by co-induction?  Induction seems to have dual versions of the same pitfalls inherent in it, and yet we avoid those pitfalls by encapsulating safe Curry-Howard recursion schemes inside named induction principles.  It turns out that we can usually do the same with <i>co-induction principles</i>.  Let us take that tack here, so that we can arrive at an <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>;</span> <span class="inlinecode"><span class="id" title="var">crush</span></span>-style proof for <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#ones_eq'"><span class="id" title="lemma">ones_eq'</span></a></span>.

<div class="paragraph"> </div>

   An induction principle is parameterized over a predicate characterizing what we mean to prove, <i>as a function of the inductive fact that we already know</i>.  Dually, a co-induction principle ought to be parameterized over a predicate characterizing what we mean to prove, <i>as a function of the arguments to the co-inductive predicate that we are trying to prove</i>.

<div class="paragraph"> </div>

   To state a useful principle for <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a></span>, it will be useful first to define the stream head function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="hd"><span class="id" title="definition">hd</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now we enter a section for the co-induction principle, based on Park's principle as introduced in a tutorial by Gimenez. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="stream_eq_coind"><span class="id" title="section">stream_eq_coind</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="stream_eq_coind.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="stream_eq_coind.R"><span class="id" title="variable">R</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
This relation generalizes the theorem we want to prove, defining a set of pairs of streams that we must eventually prove contains the particular pair we care about. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_coind.Cons_case_hd"><span class="id" title="variable">Cons_case_hd</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_coind.Cons_case_tl"><span class="id" title="variable">Cons_case_tl</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.R"><span class="id" title="variable">R</span></a> (<a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a>).<br/>

<br/>
</div>

<div class="doc">
Two hypotheses characterize what makes a good choice of <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>: it enforces equality of stream heads, and it is <i>hereditary</i> in the sense that an <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span> stream pair passes on "<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>-ness" to its tails.  An established technical term for such a relation is <i>bisimulation</i>. 
<div class="paragraph"> </div>

 Now it is straightforward to prove the principle, which says that any stream pair in <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span> is equal.  The reader may wish to step through the proof script to see what is going on. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">cofix</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s2</span>; <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.Cons_case_hd"><span class="id" title="variable">Cons_case_hd</span></a> <span class="id" title="var">H</span>); <span class="id" title="tactic">intro</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">stream_eq_coind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind.Cons_case_tl"><span class="id" title="variable">Cons_case_tl</span></a> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="section">stream_eq_coind</span></a>.<br/>

<br/>
</div>

<div class="doc">
To see why this proof is guarded, we can print it and verify that the one co-recursive call is an immediate argument to a constructor. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a>.<br/>

<br/>
</div>

<div class="doc">
We omit the output and proceed to proving <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#ones_eq''"><span class="id" title="lemma">ones_eq''</span></a></span> again.  The only bit of ingenuity is in choosing <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>, and in this case the most restrictive predicate works. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq''"><span class="id" title="lemma">ones_eq''</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>)); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that this proof achieves the proper reduction behavior via <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a></span>, rather than <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#frob"><span class="id" title="definition">frob</span></a></span> as in the last proof.  All three functions pattern match on their arguments, catalyzing computation steps.

<div class="paragraph"> </div>

   Compared to the inductive proofs that we are used to, it still seems unsatisfactory that we had to write out a choice of <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span> in the last proof.  An alternate is to capture a common pattern of co-recursion in a more specialized co-induction principle.  For the current example, that pattern is: prove <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a></span> where <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a></span> are defined as their own tails. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="stream_eq_loop"><span class="id" title="section">stream_eq_loop</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="stream_eq_loop.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> <a name="stream_eq_loop.s2"><span class="id" title="variable">s2</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_loop.Cons_case_hd"><span class="id" title="variable">Cons_case_hd</span></a> : <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_loop.loop1"><span class="id" title="variable">loop1</span></a> : <a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_loop.loop2"><span class="id" title="variable">loop2</span></a> : <a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>.<br/>

<br/>
</div>

<div class="doc">
The proof of the principle includes a choice of <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>, so that we no longer need to make such choices thereafter. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="stream_eq_loop"><span class="id" title="lemma">stream_eq_loop</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s1'</span> <span class="id" title="var">s2'</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#s1'"><span class="id" title="variable">s1'</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#s2'"><span class="id" title="variable">s2'</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>)); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop"><span class="id" title="section">stream_eq_loop</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ones_eq'''"><span class="id" title="lemma">ones_eq'''</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones"><span class="id" title="definition">ones</span></a> <a class="idref" href="Cpdt.Coinductive.html#ones'"><span class="id" title="definition">ones'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop"><span class="id" title="lemma">stream_eq_loop</span></a>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Let us put <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a></span> through its paces a bit more, considering two different ways to compute infinite streams of all factorial values.  First, we import the <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a></span> factorial function from the standard library. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Arith</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="definition">fact</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a> = <br/>
<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ 1<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> × <a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 The simplest way to compute the factorial stream involves calling <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a></span> afresh at each position. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <a name="fact_slow'"><span class="id" title="definition">fact_slow'</span></a> (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> (<span class="id" title="definition">fact</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)).<br/>
<span class="id" title="keyword">Definition</span> <a name="fact_slow"><span class="id" title="definition">fact_slow</span></a> := <a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a> 1.<br/>

<br/>
</div>

<div class="doc">
A more clever, optimized method maintains an accumulator of the previous factorial, so that each new entry can be computed with a single multiplication. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <a name="fact_iter'"><span class="id" title="definition">fact_iter'</span></a> (<span class="id" title="var">cur</span> <span class="id" title="var">acc</span> : <span class="id" title="inductive">nat</span>) := <a class="idref" href="Cpdt.Coinductive.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="Cpdt.Coinductive.html#acc"><span class="id" title="variable">acc</span></a> (<a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#cur"><span class="id" title="variable">cur</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#acc"><span class="id" title="variable">acc</span></a> <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.Coinductive.html#cur"><span class="id" title="variable">cur</span></a>)).<br/>
<span class="id" title="keyword">Definition</span> <a name="fact_iter"><span class="id" title="definition">fact_iter</span></a> := <a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> 2 1.<br/>

<br/>
</div>

<div class="doc">
We can verify that the streams are equal up to particular finite bounds. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a> <a class="idref" href="Cpdt.Coinductive.html#fact_iter"><span class="id" title="definition">fact_iter</span></a> 5.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 :: 2 :: 6 :: 24 :: 120 :: <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Coinductive.html#approx"><span class="id" title="definition">approx</span></a> <a class="idref" href="Cpdt.Coinductive.html#fact_slow"><span class="id" title="definition">fact_slow</span></a> 5.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 :: 2 :: 6 :: 24 :: 120 :: <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now, to prove that the two versions are equivalent, it is helpful to prove (and add as a proof hint) a quick lemma about the computational behavior of <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#fact"><span class="id" title="definition">fact</span></a></span>.  (I intentionally skip explaining its proof at this point.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fact_def"><span class="id" title="lemma">fact_def</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="definition">fact</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">×</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="definition">fact</span> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">ring</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">fact_def</span>.<br/>

<br/>
</div>

<div class="doc">
With the hint added, it is easy to prove an auxiliary lemma relating <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a></span>.  The key bit of ingenuity is introduction of an existential quantifier for the shared parameter <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fact_eq'"><span class="id" title="lemma">fact_eq'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="definition">fact</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)) (<a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> ⇒ <span class="id" title="notation">∃</span> <span class="id" title="var">n</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="definition">fact</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)); <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The final theorem is a direct corollary of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#fact_eq'"><span class="id" title="lemma">fact_eq'</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="fact_eq"><span class="id" title="lemma">fact_eq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> <a class="idref" href="Cpdt.Coinductive.html#fact_iter"><span class="id" title="definition">fact_iter</span></a> <a class="idref" href="Cpdt.Coinductive.html#fact_slow"><span class="id" title="definition">fact_slow</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Coinductive.html#fact_eq'"><span class="id" title="lemma">fact_eq'</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As in the case of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#ones_eq'"><span class="id" title="lemma">ones_eq'</span></a></span>, we may be unsatisfied that we needed to write down a choice of <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span> that seems to duplicate information already present in a lemma statement.  We can facilitate a simpler proof by defining a co-induction principle specialized to goals that begin with single universal quantifiers, and the strategy can be extended in a straightforward way to principles for other counts of quantifiers.  (Our <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop"><span class="id" title="lemma">stream_eq_loop</span></a></span> principle is effectively the instantiation of this technique to zero quantifiers.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="stream_eq_onequant"><span class="id" title="section">stream_eq_onequant</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="stream_eq_onequant.A"><span class="id" title="variable">A</span></a> <a name="stream_eq_onequant.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
</div>

<div class="doc">
We have the types <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span>, the domain of the one quantifier; and <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a></span>, the type of data found in the streams. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a name="stream_eq_onequant.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#stream"><span class="id" title="inductive">stream</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.B"><span class="id" title="variable">B</span></a>.<br/>
</div>

<div class="doc">
The two streams we compare must be of the forms <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>, for some shared <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>.  Note that this falls out naturally when <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> is a shared universally quantified variable in a lemma statement. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_onequant.Cons_case_hd"><span class="id" title="variable">Cons_case_hd</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#hd"><span class="id" title="definition">hd</span></a> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="stream_eq_onequant.Cons_case_tl"><span class="id" title="variable">Cons_case_tl</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="notation">∃</span> <span class="id" title="var">y</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#tl"><span class="id" title="definition">tl</span></a> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Coinductive.html#y"><span class="id" title="variable">y</span></a>.<br/>
</div>

<div class="doc">
These conditions are inspired by the bisimulation requirements, with a more general version of the <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span> choice we made for <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#fact_eq'"><span class="id" title="lemma">fact_eq'</span></a></span> inlined into the hypotheses of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="stream_eq_onequant"><span class="id" title="lemma">stream_eq_onequant</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#stream_eq_coind"><span class="id" title="lemma">stream_eq_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> ⇒ <span class="id" title="notation">∃</span> <span class="id" title="var">x</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Coinductive.html#x"><span class="id" title="variable">x</span></a>)); <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant"><span class="id" title="section">stream_eq_onequant</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fact_eq''"><span class="id" title="lemma">fact_eq''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.Coinductive.html#stream_eq"><span class="id" title="inductive">stream_eq</span></a> (<a class="idref" href="Cpdt.Coinductive.html#fact_iter'"><span class="id" title="definition">fact_iter'</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="definition">fact</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>)) (<a class="idref" href="Cpdt.Coinductive.html#fact_slow'"><span class="id" title="definition">fact_slow'</span></a> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_onequant"><span class="id" title="lemma">stream_eq_onequant</span></a>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We have arrived at one of our customary automated proofs, thanks to the new principle. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab41"></a><h1 class="section">Simple Modeling of Non-Terminating Programs</h1>

<div class="paragraph"> </div>

 We close the chapter with a quick motivating example for more complex uses of co-inductive types.  We will define a co-inductive semantics for a simple imperative programming language and use that semantics to prove the correctness of a trivial optimization that removes spurious additions by 0.  We follow the technique of <i>co-inductive big-step operational semantics</i> .

<div class="paragraph"> </div>

   We define a suggestive synonym for <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, as we will consider programs over infinitely many variables, represented as <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="var"><span class="id" title="definition">var</span></a> := <span class="id" title="inductive">nat</span>.<br/>

<br/>
</div>

<div class="doc">
We define a type <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a></span> of maps from variables to values.  To define a function <span class="inlinecode"><span class="id" title="tactic">set</span></span> for setting a variable's value in a map, we use the standard library function <span class="inlinecode"><span class="id" title="abbreviation">beq_nat</span></span> for comparing natural numbers. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="vars"><span class="id" title="definition">vars</span></a> := <a class="idref" href="Cpdt.Coinductive.html#var"><span class="id" title="definition">var</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="set"><span class="id" title="definition">set</span></a> (<span class="id" title="var">vs</span> : <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="Cpdt.Coinductive.html#var"><span class="id" title="definition">var</span></a>) (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) : <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">v'</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="abbreviation">beq_nat</span> <a class="idref" href="Cpdt.Coinductive.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Coinductive.html#v'"><span class="id" title="variable">v'</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Cpdt.Coinductive.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <a class="idref" href="Cpdt.Coinductive.html#v'"><span class="id" title="variable">v'</span></a>.<br/>

<br/>
</div>

<div class="doc">
We define a simple arithmetic expression language with variables, and we give it a semantics via an interpreter. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="exp"><span class="id" title="inductive">exp</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
| <a name="Const"><span class="id" title="constructor">Const</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a><br/>
| <a name="Var"><span class="id" title="constructor">Var</span></a> : <a class="idref" href="Cpdt.Coinductive.html#var"><span class="id" title="definition">var</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a><br/>
| <a name="Plus"><span class="id" title="constructor">Plus</span></a> : <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="evalExp"><span class="id" title="definition">evalExp</span></a> (<span class="id" title="var">vs</span> : <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a>) (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a>) : <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Var"><span class="id" title="constructor">Var</span></a> <span class="id" title="var">v</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we define a language of commands.  It includes variable assignment, sequencing, and a <tt>while</tt> form that repeats as long as its test expression evaluates to a nonzero value. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="cmd"><span class="id" title="inductive">cmd</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
| <a name="Assign"><span class="id" title="constructor">Assign</span></a> : <a class="idref" href="Cpdt.Coinductive.html#var"><span class="id" title="definition">var</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a><br/>
| <a name="Seq"><span class="id" title="constructor">Seq</span></a> : <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a><br/>
| <a name="While"><span class="id" title="constructor">While</span></a> : <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a>.<br/>

<br/>
</div>

<div class="doc">
We could define an inductive relation to characterize the results of command evaluation.  However, such a relation would not capture <i>nonterminating</i> executions.  With a co-inductive relation, we can capture both cases.  The parameters of the relation are an initial state, a command, and a final state.  A program that does not terminate in a particular initial state is related to <i>any</i> final state.  For more realistic languages than this one, it is often possible for programs to <i>crash</i>, in which case a semantics would generally relate their executions to no final states; so relating safely non-terminating programs to all final states provides a crucial distinction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoInductive</span> <a name="evalCmd"><span class="id" title="inductive">evalCmd</span></a> : <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span> :=<br/>
| <a name="EvalAssign"><span class="id" title="constructor">EvalAssign</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs</span> <span class="id" title="var">v</span> <span class="id" title="var">e</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Assign"><span class="id" title="constructor">Assign</span></a> <a class="idref" href="Cpdt.Coinductive.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#set"><span class="id" title="definition">set</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <a class="idref" href="Cpdt.Coinductive.html#v"><span class="id" title="variable">v</span></a> (<a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>))<br/>
| <a name="EvalSeq"><span class="id" title="constructor">EvalSeq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">vs2</span> <span class="id" title="var">vs3</span> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <a class="idref" href="Cpdt.Coinductive.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Seq"><span class="id" title="constructor">Seq</span></a> <a class="idref" href="Cpdt.Coinductive.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c2"><span class="id" title="variable">c2</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a><br/>
| <a name="EvalWhileFalse"><span class="id" title="constructor">EvalWhileFalse</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs</span> <span class="id" title="var">e</span> <span class="id" title="var">c</span>, <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">=</span> 0<br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> (<a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a><br/>
| <a name="EvalWhileTrue"><span class="id" title="constructor">EvalWhileTrue</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">vs2</span> <span class="id" title="var">vs3</span> <span class="id" title="var">e</span> <span class="id" title="var">c</span>, <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">≠</span> 0<br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> (<a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a>.<br/>

<br/>
</div>

<div class="doc">
Having learned our lesson in the last section, before proceeding, we build a co-induction principle for <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="evalCmd_coind"><span class="id" title="section">evalCmd_coind</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="evalCmd_coind.R"><span class="id" title="variable">R</span></a> : <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#vars"><span class="id" title="definition">vars</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="evalCmd_coind.AssignCase"><span class="id" title="variable">AssignCase</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">vs2</span> <span class="id" title="var">v</span> <span class="id" title="var">e</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Assign"><span class="id" title="constructor">Assign</span></a> <a class="idref" href="Cpdt.Coinductive.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#set"><span class="id" title="definition">set</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#v"><span class="id" title="variable">v</span></a> (<a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="evalCmd_coind.SeqCase"><span class="id" title="variable">SeqCase</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">vs3</span> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Seq"><span class="id" title="constructor">Seq</span></a> <a class="idref" href="Cpdt.Coinductive.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c2"><span class="id" title="variable">c2</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">∃</span> <span class="id" title="var">vs2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <a class="idref" href="Cpdt.Coinductive.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="evalCmd_coind.WhileCase"><span class="id" title="variable">WhileCase</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">vs3</span> <span class="id" title="var">e</span> <span class="id" title="var">c</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">=</span> 0 <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∨</span> <span class="id" title="notation">∃</span> <span class="id" title="var">vs2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">≠</span> 0 <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> (<a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs3"><span class="id" title="variable">vs3</span></a>.<br/>

<br/>
</div>

<div class="doc">
The proof is routine.  We make use of a form of <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> that takes an <i>intro pattern</i> in an <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause.  These patterns control how deeply we break apart the components of an inductive value, and we refer the reader to the Coq manual for more details. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="evalCmd_coind"><span class="id" title="lemma">evalCmd_coind</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c</span> <span class="id" title="var">vs2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">cofix</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.AssignCase"><span class="id" title="variable">AssignCase</span></a> <span class="id" title="var">H</span>); <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.SeqCase"><span class="id" title="variable">SeqCase</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> [? [? ?]]; <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind.WhileCase"><span class="id" title="variable">WhileCase</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> [[? ?] | [? [? [? ?]]]]; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind"><span class="id" title="section">evalCmd_coind</span></a>.<br/>

<br/>
</div>

<div class="doc">
Now that we have a co-induction principle, we should use it to prove something!  Our example is a trivial program optimizer that finds places to replace <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> with <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="optExp"><span class="id" title="definition">optExp</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.Coinductive.html#Const"><span class="id" title="constructor">Const</span></a> 0) <span class="id" title="var">e</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="optCmd"><span class="id" title="definition">optCmd</span></a> (<span class="id" title="var">c</span> : <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a>) : <a class="idref" href="Cpdt.Coinductive.html#cmd"><span class="id" title="inductive">cmd</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Assign"><span class="id" title="constructor">Assign</span></a> <span class="id" title="var">v</span> <span class="id" title="var">e</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Assign"><span class="id" title="constructor">Assign</span></a> <span class="id" title="var">v</span> (<a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <span class="id" title="var">e</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#Seq"><span class="id" title="constructor">Seq</span></a> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#Seq"><span class="id" title="constructor">Seq</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <span class="id" title="var">c1</span>) (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <span class="id" title="var">c2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> <span class="id" title="var">e</span> <span class="id" title="var">c</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#While"><span class="id" title="constructor">While</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <span class="id" title="var">e</span>) (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Before proving correctness of <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a></span>, we prove a lemma about <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a></span>.  This is where we have to do the most work, choosing pattern match opportunities automatically. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="optExp_correct"><span class="id" title="lemma">optExp_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs</span> <span class="id" title="var">e</span>, <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optExp"><span class="id" title="definition">optExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#evalExp"><span class="id" title="definition">evalExp</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs"><span class="id" title="variable">vs</span></a> <a class="idref" href="Cpdt.Coinductive.html#e"><span class="id" title="variable">e</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.Coinductive.html#Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <span class="id" title="constructor">O</span> ⇒ <span class="id" title="var">_</span> | <span class="id" title="constructor">S</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Cpdt.Coinductive.html#optExp_correct"><span class="id" title="lemma">optExp_correct</span></a>.<br/>

<br/>
</div>

<div class="doc">
The final theorem is easy to establish, using our co-induction principle and a bit of Ltac smarts that we leave unexplained for now.  Curious readers can consult the Coq manual, or wait for the later chapters of this book about proof automation.  At a high level, we show inclusions between behaviors, going in both directions between original and optimized programs. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">finisher</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ ((<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; [|])); <span class="id" title="tactic">subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span> 10.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="optCmd_correct1"><span class="id" title="lemma">optCmd_correct1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c</span> <span class="id" title="var">vs2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind"><span class="id" title="lemma">evalCmd_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c'</span> <span class="id" title="var">vs2</span> ⇒ <span class="id" title="notation">∃</span> <span class="id" title="var">c</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Coinductive.html#c'"><span class="id" title="variable">c'</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>)); <span class="id" title="tactic">eauto</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> ?<span class="id" title="var">E</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">discriminate</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">finisher</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="optCmd_correct2"><span class="id" title="lemma">optCmd_correct2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c</span> <span class="id" title="var">vs2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Cpdt.Coinductive.html#evalCmd_coind"><span class="id" title="lemma">evalCmd_coind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c</span> <span class="id" title="var">vs2</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">crush</span>; <span class="id" title="var">finisher</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="optCmd_correct"><span class="id" title="lemma">optCmd_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">vs1</span> <span class="id" title="var">c</span> <span class="id" title="var">vs2</span>, <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> (<a class="idref" href="Cpdt.Coinductive.html#optCmd"><span class="id" title="definition">optCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">↔</span> <a class="idref" href="Cpdt.Coinductive.html#evalCmd"><span class="id" title="inductive">evalCmd</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs1"><span class="id" title="variable">vs1</span></a> <a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.Coinductive.html#vs2"><span class="id" title="variable">vs2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intuition</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Coinductive.html#optCmd_correct1"><span class="id" title="lemma">optCmd_correct1</span></a> || <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Coinductive.html#optCmd_correct2"><span class="id" title="lemma">optCmd_correct2</span></a>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In this form, the theorem tells us that the optimizer preserves observable behavior of both terminating and nonterminating programs, but we did not have to do more work than for the case of terminating programs alone.  We merely took the natural inductive definition for terminating executions, made it co-inductive, and applied the appropriate co-induction principle.  Curious readers might experiment with adding command constructs like <tt>if</tt>; the same proof script should continue working, after the co-induction principle is extended to the new evaluation rules. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>