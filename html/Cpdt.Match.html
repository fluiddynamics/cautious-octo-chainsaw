<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.Match</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.Match</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

これまで多くの証明の自動化の例を見てきましたが、
Coqの証明探索の手続きのためのドメイン固有言語(domain-specific language)である Ltac に
よって、一部のコードの断片は魅力的なものでした(some with tantalizing code snippets)。
この章は、Ltac の機能をボトムアップに示すことを目標に、
特に、バックトラッキング探索のための独創的なアプローチをサポートする、
Ltac の <span class="inlinecode"><span class="id" title="keyword">match</span></span> 構成要素(construct)に焦点をあてます。
最初に、Coqに組み込まれている便利な自動化タクティクをいくつか実行します。
それらの詳細はマニュアルに記載されているので、出来ることを概説するだけにします。
 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab79"></a><h1 class="section">組み込み 自動化タクティク</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

多くのタクティクが <span class="inlinecode"><span class="id" title="var">crush</span></span> によって繰り返し呼び出されます。

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">intuition</span></span> タクティクは、
ゴールの命題論理的構造を簡略化(simplifies)します。
<span class="inlinecode"><span class="id" title="tactic">congruence</span></span> タクティクは、
等式と合同閉包(congruence closure)のルールに加え、帰納型のコンストラクタの属性を適用します。
<span class="inlinecode"><span class="id" title="tactic">omega</span></span> タクティクは、あなたの求めに応じて(depending on whom you ask)、
quantifier-free linear arithmetic 量化子のない線形算術、または、
Presburger arithmetic プレスバーガー算術と呼ばれる
理論に対する完全な決定手続きを提供します。
すなわち <span class="inlinecode"><span class="id" title="tactic">omega</span></span> は、
その原始式(atomic formulas)が、自然数または整数を基本的な比較演算の対象とし、
そのオペランドが定数、変数、加算および減算から構成された、
（加算または減算の省略形として利用可能な定数による乗算を含む）
命題論理の式として解釈されることのできる、
ゴールの部分のみを見ることに続く
(that follows from looking only at parts of that goal)
任意のゴールを証明します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">ring</span></span> は、
関与する型に依存して、(代数のように)環まはた半環の公理を適用することによって、
ゴールを解きます。
Coqの開発では、関連する公理を証明することによって、
新しい型を環と半環の一部として宣言することができます。
環における分数に変換することで、
体の値を簡略化するための同様のタクティク <span class="inlinecode"><span class="id" title="tactic">field</span></span> があります。
<span class="inlinecode"><span class="id" title="tactic">ring</span></span> と <span class="inlinecode"><span class="id" title="tactic">field</span></span> の両方は、等式のゴールだけを解くことができます。
<span class="inlinecode"><span class="id" title="tactic">fourier</span></span> タクティクは、
Coq標準ライブラリで公理化された実数の不等式を証明するフーリエの方法を使用します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

The <i>setoid</i> の手法(facility)は、
<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> のようなタクティクによって理解される
新しい等価関係(equivalence relations)を
登録することを可能にします。
たとえば <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> は、"if and only if" の等価関係を setoid として登録されています。
新しい setoid を登録する能力は、
すべての推論(reasoning)が、
「関係によって改変された(modding out by a relation)」後に実行される箇所において、
数学で一般的な種類の証明において非常に有用です。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Coq マニュアルを熟読することで学ぶことのできる、
組み込みの「ブラックボックス」な自動化タクティクがあります。
Coqの本当の約束事は、Ltacを使って、
問題に特化したタクティクのコーディングのなかにあります。
 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab80"></a><h1 class="section">Ltac プログラミングの基礎</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

すでに Ltac プロラムの多くの例を見てきました。
本章の残りでは、重要な機能とデザインパターンを徹底的に紹介しようとします。

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">match</span></span> タクティクのひとつの共通の使い方は、
このタクティクの定義にあるように、
条件分析(case analysis)のための内容の識別です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">find_if</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">if</span> ?<span class="id" title="var">X</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このタクティクは結論が <span class="inlinecode"><span class="id" title="keyword">if</span></span> かどうかチェックし、もしそうなら、
条件式(test expression)を <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> します。
ある特定の種類の定理は、このようなタクティクによって、
自動的に証明することが簡単(trivial)です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="hmm"><span class="id" title="lemma">hmm</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="inductive">bool</span>),<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#b"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#c"><span class="id" title="variable">c</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="inductive">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">repeat</span> <span class="id" title="var">find_if</span>; <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで使った <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> は、
 <i>tactical</i> タクティカル または タクティク・コンビネータ(tactic combinator)
と呼ばれます。
<span class="inlinecode"><span class="id" title="tactic">repeat</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> の振る舞いは、<span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> を実行し、
すべての生成されたサブゴールに <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> を実行し、
<i>それら</i> が生成したサブゴールに <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> を実行し、というぐあいに、
繰り返し続けることです。
この探索木の任意の点で <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> が失敗したとき、その特定のサブゴールは、
後のタクティクのによって扱われるために残されます。
なので、いつも成功するタクティクと一緒に <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> を使用しないことが重要です。

<div class="paragraph"> </div>

他のとても便利な Ltac の構成要素(building block)は、
 <i>context patterns</i> コンテキスト・パターン
です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">find_if_inside</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">if</span> ?<span class="id" title="var">X</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span>] ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このタクティクの振る舞いは、結論の
<span class="inlinecode"><span class="id" title="keyword">if</span></span> であり、その後に条件式を <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> する任意の部分項(subterm)を見つけることです。
このバージョンは <span class="inlinecode"><span class="id" title="var">find_if</span></span> を含みます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="hmm'"><span class="id" title="lemma">hmm'</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="inductive">bool</span>),<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#b"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#c"><span class="id" title="variable">c</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="inductive">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">repeat</span> <span class="id" title="var">find_if_inside</span>; <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">find_if</span>-<span class="id" title="var">inside</span></span> を
<span class="inlinecode"><span class="id" title="var">find_if</span></span> が十分に簡約できなかったゴールを証明するために使うことができます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="hmm2"><span class="id" title="lemma">hmm2</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="inductive">bool</span>),<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="keyword">then</span> 42 <span class="id" title="keyword">else</span> 42<span class="id" title="notation">)</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.Match.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> 42 <span class="id" title="keyword">else</span> 42<span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">repeat</span> <span class="id" title="var">find_if_inside</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

多くの決定性の手続きは 「<span class="inlinecode"><span class="id" title="tactic">repeat</span></span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> ループ」によって Ltac で記述することができます。
たとえば、<span class="inlinecode"><span class="id" title="tactic">tauto</span></span> のサブセットの機能を実装することができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">my_tauto</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> |- ?<span class="id" title="var">P</span> ] ⇒ <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="inductive">True</span> ] ⇒ <span class="id" title="tactic">constructor</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">constructor</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="notation">→</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">intro</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="inductive">False</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> <span class="id" title="notation">∨</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H1</span> : ?<span class="id" title="var">P</span> <span class="id" title="notation">→</span> ?<span class="id" title="var">Q</span>, <span class="id" title="var">H2</span> : ?<span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">match</span></span> のパターンはユニフィケーション変数を仮定と結論のパターンの間で共有することができ、
結論が仮説といつマッチするかを把握することは容易です。
<span class="inlinecode"><span class="id" title="tactic">exact</span></span> タクティクは、適切な型の証明項が与えられているとき、
ゴールを完全に解きます。

<div class="paragraph"> </div>

（自然演繹 natural deduction の意味において）
いくつかの結合子についての導入(introduction)のルールを実装することもまた自明です。
除去(elimination)のルールを実装することはもう少しの作業です。
<span class="inlinecode"><span class="id" title="tactic">destruct</span></span>に仮説の名前を付ける必要があるからです。

<div class="paragraph"> </div>

最後のルールは、
仮説を与えられた引数の集合（量化された変数、または、含意による局所的仮説のため）
に特化したバージョンに置き換える <span class="inlinecode"><span class="id" title="tactic">specialize</span></span> タクティクを使って
三段論法(modus ponens)を実装します。
慣例によって、
<span class="inlinecode"><span class="id" title="tactic">specialize</span></span> への引数が一連の引数に対する仮説 <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> の適用である場合、そ
の特殊化の結果が <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> に置き換えられます。
 他の項については、結果は <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> と同じです。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="propositional"><span class="id" title="section">propositional</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="propositional.P"><span class="id" title="variable">P</span></a> <a name="propositional.Q"><span class="id" title="variable">Q</span></a> <a name="propositional.R"><span class="id" title="variable">R</span></a> : <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="propositional"><span class="id" title="lemma">propositional</span></a> : <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#propositional.P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.Match.html#propositional.Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∨</span> <span class="id" title="inductive">False</span><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#propositional.P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#propositional.Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">True</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#propositional.Q"><span class="id" title="variable">Q</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">my_tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#propositional"><span class="id" title="section">propositional</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

すべての含意(implication)を消すこと(clearing)によって情報を失なわないので、
三段論法の実装をするのは比較的簡単です。
もし、量化された含意についての同様の完全な手続きを実装するなら、
特定の命題がまだ仮説に含まれていないことを保証する方法が必要です。
これを効果的に行うには、最初に <span class="inlinecode"><span class="id" title="keyword">match</span></span> の意味についてもう少し学ぶ必要があります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">match</span></span> はMLのように動作すると想定するのは魅力的です。 
実際に、その動作にはいくつかの重要な違いがあります。
ひとつは、変数やコンストラクタに制限されることなく、パターンに任意の式を含めることです。 
もうひとつは、同じ変数が複数回現れることがあり、暗黙に等値の制約を含むことです。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

他のふたつの違いは、他のものよりはるかに重要です。
<span class="inlinecode"><span class="id" title="keyword">match</span></span> 構文は、 <i>失敗によるバックトラッキングの意味</i> を持っています。 
MLでは、パターンマッチングは、一致させる最初のパターンを見つけてから、
その本体を実行することによって動作します。 
本体が例外を発生させた場合、全体の一致は同じ例外を発生させます。
Coqでは、ケース条件本体の失敗は、代わりにケースのリストを通じて検索を続行します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

例えば、この（不必要で冗長な）証明のスクリプトはこのように動きます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="m1"><span class="id" title="lemma">m1</span></a> : <span class="id" title="inductive">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="inductive">True</span> ] ⇒ <span class="id" title="tactic">constructor</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

最初のケースは簡単に一致しますが、その結論は限定子や含意から始まるわけではないので、
その本体のタクティクは失敗します。
同様のMLのマッチでは、パターンマッチ全体が失敗します。
Coqでは、次のパターンを取り戻して試してみます。これも一致します。
その本体のタクティクは成功するので、全体のタクティクも成功します。

<div class="paragraph"> </div>

この例では、失敗が <span class="inlinecode"><span class="id" title="keyword">match</span></span> 内の別のパターンにどのように移動するかを示しています。
失敗はまた、<i>単一のパターンにマッチする異なる方法を見つける試み</i>を引き起こします。
別の例を考えてみましょう。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="m2"><span class="id" title="lemma">m2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">idtac</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Coq は <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span> を印刷します。
ひとつの引数を取って <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> を適用することは、
<span class="inlinecode"><span class="id" title="keyword">match</span></span> 情報を取り出すための便利なデバッキングツールです。
この <span class="inlinecode"><span class="id" title="keyword">match</span></span> は最初に <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> を <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span> に束縛しようとしますが、
<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span> は <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> を証明するために使用できません。
それにもかかわらず、タクティクの次のバリエーションはゴールを証明するのに成功します：
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

タクティクは最初に <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> と <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span>  をユニファイします、
その場合は <span class="inlinecode"><span class="id" title="tactic">exact</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> が失敗するため、戦術エンジンは <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> の可能な値をさらに検索します。
最終的には、正しい値  に到達するので、<span class="inlinecode"><span class="id" title="tactic">exact</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> と全体のタクティクは成功します。
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

では、命題が私たちの仮説の中にないことを確認するためのタクティクを実装する用意ができました：
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">notHyp</span> <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">P</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">P2</span> ⇒ <span class="id" title="tactic">first</span> [ <span class="id" title="var">notHyp</span> <span class="id" title="var">P1</span> | <span class="id" title="var">notHyp</span> <span class="id" title="var">P2</span> | <span class="id" title="tactic">fail</span> 2 ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

パターン・マッチングにに組み込まれている等価性検査(equality checking)を使用して、
命題に正確に一致する仮説があるかどうかを調べます。もしそうなら、
<span class="inlinecode"><span class="id" title="tactic">fail</span></span> タクティクを使用します。 
引数がなければ、期待通りに、<span class="inlinecode"><span class="id" title="tactic">fail</span></span> は通常のタクティクの失敗を通知します。
<span class="inlinecode"><span class="id" title="tactic">fail</span></span> に引数 <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> が渡されると、
<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> は、バックトラック探索の囲む条件(case)を通して外側に向かってカウントするように使用されます。
この場合、<span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">1</span>は、「パターン・マッチングの分岐ではなく、<span class="inlinecode"><span class="id" title="var">macth</span></span> 全体を失敗させる」
ことを示します。
<span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">1</span> に達すると、2番目の条件(case)は決して試行されません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

第2の条件(case)は、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> が仮説と一致しないときに使用され、
<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> が連言(conjunction)であるかどうかをチェックします。
他の簡略化(simplification)では連言(conjunction)をその成分の式(component formula)
に分割することがあるため、
これらの成分の少なくともひとつも表現されていない
ことを確認する必要があります。
これを達成するために、 <span class="inlinecode"><span class="id" title="tactic">first</span></span> タクティカルを適用します。
これはタクティクのリストを取り、
それらのひとつが失敗しないまで リストを続けます。
最後の <span class="inlinecode"><span class="id" title="tactic">fail</span></span> <span class="inlinecode">2</span> は、<span class="inlinecode"><span class="id" title="tactic">first</span></span> とその周囲に巻き込まれた <span class="inlinecode"><span class="id" title="keyword">match</span></span> の両方が失敗することを示します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode">?<a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode">?<a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a></span> の場合のボディ は、
到達すれば完全に成功するか完全に失敗するかを保証します。
ワイルドカードの場合、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> は連言ではありませんから、
<span class="inlinecode"><span class="id" title="tactic">idtac</span></span> を使用します。
これは、何もしないことで成功する効果があるため、単独で適用することは愚かなタクティクです。
それにもかかわらず、<span class="inlinecode"><span class="id" title="tactic">idtac</span></span> は、ここで見ているような場合に便利な代用品(placeholder)です。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

存在しないことのチェックを実装したことによって、
入力として証明項をとり、結論がまだ存在しない場合だけ、新しい仮説としてその結論を加え、
さもなければ失敗するタクティクを作ることは簡単です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">extend</span> <span class="id" title="var">pf</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t</span> := <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">notHyp</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">generalize</span> <span class="id" title="var">pf</span>; <span class="id" title="tactic">intro</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Ltacの有用な <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> <span class="inlinecode"><span class="id" title="var">of</span></span> 演算子があります。
この演算子はGallinaでは実装できませんでしたが、Ltacでサポートするのは簡単です。

<div class="paragraph"> </div>

最終的に <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> は <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> の型を束縛します。
<span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> がまだ存在していないことを確認します。
もしそうなら、<span class="inlinecode"><span class="id" title="tactic">generalize</span></span> / <span class="inlinecode"><span class="id" title="tactic">intro</span></span> の組み合わせを使って、
<span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> によって証明された新しい仮説を追加します。 

<div class="paragraph"> </div>

タクティク <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> は、
入力として <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span>（例えば命題の証明）をとり、
<span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> が <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> の型であるとき、<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> から <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.G"><span class="id" title="definition">G</span></a></span> に結論を変えます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

これらの定義されたタクティクで、
単純な一階論理の式の集合のすべての結果(consequence)
をコンテキストに加えるためのタクティク <span class="inlinecode"><span class="id" title="var">completer</span></span> を書くことができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">completer</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">constructor</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> <span class="id" title="notation">→</span> ?<span class="id" title="var">Q</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">H'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">intro</span>    <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, ?<span class="id" title="var">P</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <span class="id" title="var">_</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">P</span> ?<span class="id" title="var">X</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="var">extend</span> (<span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">H'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
前の扱ったのと同じ種類の連言と含意を使います。
<span class="inlinecode">→</span> は <span class="inlinecode"><span class="id" title="keyword">∀</span></span> の 依存しない特別な場合なので、
第4のルールでは <span class="inlinecode"><span class="id" title="tactic">intro</span></span> で含意も扱うことに注意してください。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

第5のルールでは、私たちが仮説のひとつにマッチする前提で <span class="inlinecode"><span class="id" title="keyword">∀</span></span> (を含む)事実 <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> を見つけたら、
まだ追加していなければ、<span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> の結論を適切に具体化(instantiation)したものを追加します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

偽作(spurious)の変数を導入する、説明上の目的(didactic purpose)の定理を用いて、
すぐに、<span class="inlinecode"><span class="id" title="var">completer</span></span> が正しく働いていることを確認することができます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="firstorder"><span class="id" title="section">firstorder</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="firstorder.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="firstorder.P"><span class="id" title="variable">P</span></a> <a name="firstorder.Q"><span class="id" title="variable">Q</span></a> <a name="firstorder.R"><span class="id" title="variable">R</span></a> <a name="firstorder.S"><span class="id" title="variable">S</span></a> : <a class="idref" href="Cpdt.Match.html#firstorder.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="firstorder.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#firstorder.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#firstorder.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="firstorder.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#firstorder.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fo"><span class="id" title="lemma">fo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">y</span> <span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Match.html#firstorder.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.Match.html#firstorder.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">completer</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">H0</span> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.H3"><span class="id" title="variable">H3</span></a> : <a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#test_inster.H4"><span class="id" title="variable">H4</span></a> : <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#firstorder"><span class="id" title="section">firstorder</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

かろうじて <span class="inlinecode"><span class="id" title="var">completer</span></span> の定義における微妙な落とし穴を避けていました。
慣れていない目には、オリジナルよりも魅力的に見える別の定義を試してみましょう。
（2番目の <span class="inlinecode"><span class="id" title="keyword">match</span></span> の場合を少し変更して、
これまでに行使されていなかったLtacの動作の微妙な部分を処理するのに
十分スマートなタクティクにしました）。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">completer'</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">constructor</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">Q</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H'</span> : <span class="id" title="var">P</span> <span class="id" title="notation">∧</span> <span class="id" title="var">Q</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">clear</span> <span class="id" title="var">H'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : ?<span class="id" title="var">P</span> <span class="id" title="notation">→</span> <span class="id" title="var">_</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">P</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">H'</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">intro</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, ?<span class="id" title="var">P</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <span class="id" title="var">_</span>, <span class="id" title="var">H'</span> : ?<span class="id" title="var">P</span> ?<span class="id" title="var">X</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="var">extend</span> (<span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">H'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

他の唯一の違いは、未使用のユニフィケーション変数 <span class="inlinecode">?<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> をワイルドカードに置き換えた三段論法
(modus ponens) のルールにあります。 このバージョンで再び例を試してみましょう：
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="firstorder'"><span class="id" title="section">firstorder'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="firstorder'.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="firstorder'.P"><span class="id" title="variable">P</span></a> <a name="firstorder'.Q"><span class="id" title="variable">Q</span></a> <a name="firstorder'.R"><span class="id" title="variable">R</span></a> <a name="firstorder'.S"><span class="id" title="variable">S</span></a> : <a class="idref" href="Cpdt.Match.html#firstorder'.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="firstorder'.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#firstorder'.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder'.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#firstorder'.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="firstorder'.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#firstorder'.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder'.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fo'"><span class="id" title="lemma">fo'</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">y</span> <span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Match.html#firstorder'.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.Match.html#firstorder'.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#firstorder'.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">completer'</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.H2"><span class="id" title="variable">H2</span></a> : <a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

証明できていたゴールを証明できないものに変形(reducing)することで、
量化された定理は、<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>ではなく<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>で具体化されてしまいます。
<span class="inlinecode"><span class="id" title="var">completer'</span></span> のための最後の <span class="inlinecode"><span class="id" title="keyword">match</span></span> の条件は、
適切な仮説とともに量化子を具体化するだけに注意深くしています。
なぜ間違った選択が行われたのですか？
     
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Abort</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#firstorder'"><span class="id" title="section">firstorder'</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

いくつかの例が問題を説明しているはずです。ここでは、
<span class="inlinecode"><span class="id" title="keyword">match</span></span>にもとづく証明がうまくいくのを見ています：
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t1"><span class="id" title="lemma">t1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">trivial</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This one fails. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t1'"><span class="id" title="lemma">t1'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>, ?<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ] ⇒ <span class="id" title="tactic">trivial</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: No matching clauses for match goal
</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>. 
<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

問題は、ユニフィケーション変数にローカルに束縛された変数が含まれないことです。
この場合、<span class="inlinecode">?<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> はローカルな量化変数 <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> を含む <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> に束縛される必要があります。
以前のバージョンでワイルドカードを使用することで、この制限は回避されました。
なぜこの制限が <span class="inlinecode"><span class="id" title="var">completer</span></span> タクティクの振る舞いに影響を与えるのかを理解するために、
Coqでは、含意が縮退(degenerate)した全称量化の略記であることを思い出してください。
それにもかかわらず、Ltacパターンでは、
Coqはワイルドカードの含意と全称量化のマッチに満足してしまいます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Coq 8.2リリースには、明示的な自由変数の集合を持つユニフィケーション変数用の
特別なパターン形式が含まれています。
そのユニフィケーション変数は、
自由変数から「実」値への関数に束縛されます。
Coq 8.1以前では、このような回避策はありません。
15.5節でこの手の込んだバインディングフォームの例を見ていきます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

どのCoqバージョンを使用していても、この制限に注意することが重要です。
すでに示唆したように、その制限は <span class="inlinecode"><span class="id" title="var">completer'</span></span> の驚くべき振る舞いの背後にある原因です。
私たちは間違って量化された事実を三段論法と突き合わせ、
適切に一致する仮説が利用可能であり、
誤った量化子の具体化が選択された異なる行動につながるというチェックを回避します。
私たちの初期の <span class="inlinecode"><span class="id" title="var">completer</span></span> タクティクでは、
含意の結論と変数を組み合わせた三段論法を使用しています。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

実際、ここで示した動作はCoqバージョン8.4に適用されますが、8.4pl1には適用されません。
後者のバージョンでは、通常のLtacパターン変数がローカルに束縛された変数を含む項に
一致することができますが、
その変数が後にGallina項として使用されると、タクティクの失敗が発生します。
 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab81"></a><h1 class="section">Ltac による関数プログラミング</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Ltacは、構文付きLisp(Lisp-with-syntax)風の非常に便利な関数型プログラミングをサポートしています。
受け入れてもらうための、プログラムに関係するいくつかの構文上の慣習があります。
Ltacの構文はタクティクの記述のために最適化されているので、
より標準的な関数プログラムを書く際にいくつかの不都合を扱わなければなりません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

説明のために、簡単なリストの長さを求める関数を記述しましょう。
あたかもGallinaのように、<span class="inlinecode"><span class="id" title="var">Fixtpoint</span></span>（とその注釈(annotation)）
を<span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>に置き換えて書き始めます。

<div class="paragraph"> </div>

   <br/>
<span class="inlinecode"><span class="id" title="keyword">Ltac</span> <a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <a class="idref" href="Cpdt.InductiveTypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> :: <a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: The reference ls' was not found in the current environment
</pre>

<div class="paragraph"> </div>

この時点で、Ltacでは、
パターン変数の名前の先頭に疑問符を付ける必要があることを覚えておいてください。

<div class="paragraph"> </div>

   <br/>
<span class="inlinecode"><span class="id" title="keyword">Ltac</span> <a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <a class="idref" href="Cpdt.InductiveTypes.html#O"><span class="id" title="constructor">O</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> :: ?<a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: The reference S was not found in the current environment
</pre>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

問題は、Ltacが式 <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a>)</span> を引数 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#ls'"><span class="id" title="variable">ls'</span></a></span> を持つタクティク <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> の呼び出しとして
扱うことです。
Gallinaの非終端記号の構文解析を「エスケープ」するために特別なアノテーションを
使用する必要があります。  

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">length</span> <span class="id" title="var">ls</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> ?<span class="id" title="var">ls'</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="constructor">S</span> (<span class="id" title="definition">length</span> <span class="id" title="var">ls'</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この定義は受け入れられます。
このようなLtacの定義をテストするのはちょっと厄介です。
ひとつの方法があります。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="inductive">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">length</span> (1 <span class="id" title="notation">::</span> 2 <span class="id" title="notation">::</span> 3 <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> := <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> (2 :: 3 :: <span class="id" title="constructor">nil</span>)) : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

特定の項に、等号でセットされた(set equal to)、新しい変数でもって、証明のコンテキストを拡張する
<span class="inlinecode"><span class="id" title="tactic">pose</span></span> タクティクを使用します。
<span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> の代わりに <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> を使用することもできました。
これは、コンテキストを変更せずに結果を出力します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>の値は、長さの計算の1ステップだけ展開されます。
ここで起こったことは、<span class="inlinecode"><span class="id" title="keyword">constr</span></span> 非終端記号にエスケープすることによって、
私たちが定義している Ltac関数 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> は、Gallinaの関数 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> を参照したことです。
   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">length</span>.<br/>

<br/>
</div>

<div class="doc">
覚えておくべきことは、タクティクによって作られた Gallina項は、
Ltac 呼び出しを他の Gallina項 に直接挿入するのではなく、
<span class="inlinecode"><span class="id" title="keyword">let</span></span> または同様の手法を介して明示的に束縛する必要があるということです。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">length</span> <span class="id" title="var">ls</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> ?<span class="id" title="var">ls'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ls''</span> := <span class="id" title="var">length</span> <span class="id" title="var">ls'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="constructor">S</span> <span class="id" title="var">ls''</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="inductive">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">length</span> (1 <span class="id" title="notation">::</span> 2 <span class="id" title="notation">::</span> 3 <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> := 3 : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

標準のリストの <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a></span> 関数のこの例が示すように、
Ltacで無名関数の式とローカルな関数定義を使用することもできます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">map</span> <span class="id" title="var">T</span> <span class="id" title="var">f</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">map'</span> <span class="id" title="var">ls</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="keyword">constr</span>:(@<span class="id" title="constructor">nil</span> <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">x</span> <span class="id" title="notation">::</span> ?<span class="id" title="var">ls'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x'</span> := <span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ls''</span> := <span class="id" title="var">map'</span> <span class="id" title="var">ls'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">x'</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls''</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="var">map'</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Ltac関数は暗黙の引数を持つことができません。
出力リストの要素の型(carried type of the output list)である<span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span>を
明示的に渡す必要があることは驚くようです。
<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a></span> は Gallinaの項ではなくLtacの項であり、
Ltacプログラムは動的に型付けされているので、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> <span class="inlinecode"><span class="id" title="var">of</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a></span> を使うことはできません。
関数 <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a></span> は、非常に構文的な方法を使用して、
異なる入力に対して異なる型の項を返すことを決定することができます。
<span class="inlinecode"><span class="id" title="keyword">constr</span>:(@<span class="id" title="constructor">nil</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a>)</span> を <span class="inlinecode"><span class="id" title="keyword">constr</span>:<span class="id" title="constructor">nil</span></span> に置き換えることもできませんでした。
これは、パラメータを <span class="inlinecode"><span class="id" title="constructor">nil</span></span> に推論するために使用する強く型付けされたコンテキストがないためです。
幸いにも、<span class="inlinecode"><span class="id" title="keyword">constr</span>:(<a class="idref" href="Cpdt.GeneralRec.html#x'"><span class="id" title="variable">x'</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#ls''"><span class="id" title="variable">ls''</span></a>)</span> の中には十分なコンテキストを持っています。

<div class="paragraph"> </div>

複雑なタクティクの表現を別のタクティクに引数として渡したいときには、
<tt>map</tt> を呼び出す際にしたように、
「非終端のエスケープ」の反対の方向を採用する必要がある場合があります。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="inductive">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ls</span> := <span class="id" title="var">map</span> (<span class="id" title="inductive">nat</span> <span class="id" title="notation">×</span> <span class="id" title="inductive">nat</span>)%<span class="id" title="var">type</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="notation">(</span><span class="id" title="var">x</span><span class="id" title="notation">,</span> <span class="id" title="var">x</span><span class="id" title="notation">)</span>)) (1 <span class="id" title="notation">::</span> 2 <span class="id" title="notation">::</span> 3 <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">ls</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> := (1, 1) :: (2, 2) :: (3, 3) :: <span class="id" title="constructor">nil</span> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> × <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Ltacスクリプトの中の各位置には、
既定の適用可能な非終端記号があります。
ここで、<span class="inlinecode"><span class="id" title="keyword">constr</span></span>と<span class="inlinecode"><span class="id" title="keyword">ltac</span></span>は、
GallinaとLtacの条件をそれぞれ念頭に置く価値のある主要なオプションです。
明示的なコロン表記は、既定の非終端選択を無効にするためにいつでも使用することができますが、
Gallinaとして解析されるコードではこのような上書きは使用できなくなります。
<span class="inlinecode"><span class="id" title="keyword">ltac</span></span>非終端の関数アプリケーションは、GallinaではなくLtacのアプリケーションとして扱われます。
そのような関数への <i>引数</i> はデフォルトで <span class="inlinecode"><span class="id" title="keyword">constr</span></span> で解析されます。
この選択は、私たちが書いているすべての証明スクリプトにすべて頼っていることがわかるまで、
奇妙に見えるかもしれません！
例えば、<span class="inlinecode"><span class="id" title="tactic">apply</span></span> タクティクはLtac関数であり、
その引数をLtacではなくGallinaの項として解釈するのは当然です。
上記の <tt>map</tt> の呼び出しのように、
<span class="inlinecode"><span class="id" title="keyword">ltac</span></span>接頭辞を使用してLtac関数の引数をLtac項として解析します。
いくつかの単純なケースでは、Ltac項は余分なプレフィックスなしで渡されることがあります。
例えば、Ltacの意味を持ち、Gallinaの意味を持たない識別子は自動的にLtacで解釈されます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Ltacの機能プログラムをデバッグしたいときには、もうひとつの問題があります。
呼び出された引数のデバッグ・トレースを出力する
<tt>length</tt>
バージョンを提供するには、次のコードが必要です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">length</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">length</span> <span class="id" title="var">ls</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> <span class="id" title="var">ls</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> ?<span class="id" title="var">ls'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ls''</span> := <span class="id" title="var">length</span> <span class="id" title="var">ls'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="constructor">S</span> <span class="id" title="var">ls''</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Coqはタクティクの定義を受け入れますが、コードには致命的な欠陥があり、
常に動的なタイプのエラーにつながります。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="inductive">False</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> := <a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> (1 :: 2 :: 3 :: <span class="id" title="constructor">nil</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: variable n should be bound to a term.
</pre>
 
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
ここで何がうまくいかないのでしょうか？
答えは、Ltacの、純粋に関数プログラミング言語と命令的プログラミング言語の両方としての
二重状態 (dual status) と関係しています。
基本的なプログラミング言語は純粋に関数的ですが、
タクティクスクリプトはそのようなプログラムによって返される「データ型」のひとつで、
Coqは証明状態を変更する命令的なセマンティクスを使ってそのようなスクリプトを実行します。
 Haskell の
 モナド・プログラミング(monadic programming)に
精通している読者は、類似点を認識しているかもしれません。
副作用を伴うHaskellプログラムは、
<i>命令型言語におけるプログラムのコード</i>
(the code of programs in an imperative language) を
返す純粋なプログラムと考えることができます。
一部の帯域外(out-of-band)なメカニズムは、
これらの派生プログラムを実行する責任を負います。
このようにして、Haskellは純粋なままで、通常の入出力の副作用などをサポートします。
Ltacは同じ基本メカニズムを使用しますが、動的に型付けされます。
ここで埋め込まれた命令的言語には、これまで適用されてきたすべてのタクティクが含まれます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

基本的な <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> も組み込みの命令型プログラムなので、
純粋に機能的なコードと自動的には混合しないかもしれません。
実際には、セミコロン演算子だけでLtacコードのスパンを
組み込みのタクティクのスクリプトとしてマークしています。
純粋な関数型言語では順序付けの必要がないので、
副作用がないため、式を実行してからその値を捨て、別の式に移る理由はありません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Haskell のモナド（それ自体は巧妙な考え方であると思われますが）に対する類推を
避けるための代替的な説明は次のとおりです。
Ltacのタクティクのプログラムは、
後で実行されるときに望ましい証明の変形(proof modification)を実行する関数を返します。
これらの関数は、他のデータ型や数やGallina項とは異なります。
Gallina項でのみ計算された <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> の以前の正しく動作していたバージョンですが、
<span class="inlinecode"><span class="id" title="tactic">idtac</span></span> とセミコロンの使用で示されるように、新しい関数は暗黙的に関数を返しています。
しかし、新しいバージョンの <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> の再帰的呼び出しは、
出力としてGallina項をタクティクの関数ではないと予想するように構成されています。
その結果、基本的な動的な型エラーが発生します。
おそらくファーストクラスのタクティクのスクリプトが関与しています。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

結果はHaskellに似ています。
純粋なプログラムを「モナド化」して、副作用にアクセスできるようにする必要があります。
問題は組み込まれたタクティクの言語には <span class="inlinecode"><span class="id" title="keyword">return</span></span> の構造がないことです。
証明スクリプトは、結果を計算するのではなく、定理を証明することに関するものです。
プログラムを

<i>継承渡しスタイル</i> (continuation-passing style) 
に変換する必要があるやや難しい回避策を適用することができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">length</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">length</span> <span class="id" title="var">ls</span> <span class="id" title="var">k</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">idtac</span> <span class="id" title="var">ls</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="var">k</span> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> ?<span class="id" title="var">ls'</span> ⇒ <span class="id" title="var">length</span> <span class="id" title="var">ls'</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">k</span> (<span class="id" title="constructor">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

新しい <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> は、新しい入力を受け取ります: <i>継続</i> (continuation) <span class="inlinecode"><a class="idref" href="Cpdt.LogicProg.html#k"><span class="id" title="variable">k</span></a></span> は、
<tt>length</tt> を呼び出した途中でどのようなプロセスがあったとしても
継続するために呼び出される関数です。
<span class="inlinecode"><a class="idref" href="Cpdt.LogicProg.html#k"><span class="id" title="variable">k</span></a></span> に渡される引数は、<tt>length</tt> の戻り値と考えることができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="inductive">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (1 <span class="id" title="notation">::</span> 2 <span class="id" title="notation">::</span> 3 <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>) <span class="id" title="keyword">ltac</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="tactic">pose</span> <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">(1 :: 2 :: 3 :: <span class="id" title="constructor">nil</span>)<br/>
(2 :: 3 :: <span class="id" title="constructor">nil</span>)<br/>
(3 :: <span class="id" title="constructor">nil</span>)<br/>
<span class="id" title="constructor">nil</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちは最初に期待した関数引数のトレースを正確に見て、
その後の証明に状態を調べると、変数<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>に値<span class="inlinecode">3</span>が追加され
ていることがわかります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

HaskellのIOモナドとの比較を考えると、言及する価値のある微妙なことがあります。
HaskellのI/O計算は、実世界のある状態から別の状態への変換器と、返す純粋な値を
（理論的に言えば、少なくとも）表現します。
状態の一部は、ヒープ割り当ての変更可能な参照の場合のように、
プログラム固有のものもありますが、
プログラムが、現実世界に元に戻すことができない副作用を及ぼす
お気に入りの例「ミサイル発射」の線に沿っているものもあります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

対照的に、Ltacのスクリプトは、単に2つの単純な種類の可変状態を制御するものと考えることができます。
第1に、証明のサブゴールの現在のシーケンスが存在します。
第2に、前の章で見たように、証明検索によって導入されたユニフィケーション変数に発見された値を部分的に
割り当てます（たとえば、<span class="inlinecode"><span class="id" title="tactic">eauto</span></span>）。
重要なことは、<span class="inlinecode"><span class="id" title="keyword">match</span></span>、<span class="inlinecode"><span class="id" title="tactic">auto</span></span>、および、その他のLtacを構成する組み込みのものによって導かれた
バックトラッキングの間には、
<i>この状態のあらゆる変異を元に戻すことができる</i> ということです。
Ltac証明スクリプトには状態がありますが、
それは純粋にローカルなものであり、すべての変更は可逆的です。
これは証明検索のための非常に便利なセマンティクスです。
 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab82"></a><h1 class="section">再帰的な証明探索</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

量化子をどのように具体化するかの決定は、
自動化された一階の定理の証明の最も難しい部分のひとつです。
与えられた問題によっては、最終的に命題の推論だけを適用することで、
量化子のインスタンス可能な全てからなる有限長のシーケンスを考えることができます。
これは、ほぼすべてのゴールに対して悪い考えですが、
Ltacの再帰的な証明探索の手順の素晴らしい例になります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

一階の証明のために最大の「依存鎖(dependency chain)」の長さを考慮することができます。
仮説の鎖の長を0とし、
量化された事実を具体化したものの鎖長をその事実の長さより、1だけ大きいものと定義します。
タクティク <span class="inlinecode"><span class="id" title="var">inster</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> は、鎖の長さの最大 <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> で、可能なすべての証明を試すことを意図しています。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">inster</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intuition</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> ?<span class="id" title="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">T</span>, <span class="id" title="var">_</span>, <span class="id" title="var">y</span> : ?<span class="id" title="var">T</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H</span> <span class="id" title="var">y</span>); <span class="id" title="var">inster</span> <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このタクティクは、命題の単純化を適用することから始まります。
次に、鎖長が残っているかどうかをチェックし、そうでない場合は失敗します。
それ以外の場合は、適切に型付けされたローカル変数を使用して
量化された仮説を具体化するすべての可能な方法を試行します。
再帰呼び出し <span class="inlinecode"><span class="id" title="var">inster</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a></span> が失敗した場合、<span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="keyword">goal</span></span> は、
そのパターンを証明の状態とユニファイする別の方法を探していることに気付くことが重要です。
したがって、この少量のコードは、バックトラック <span class="inlinecode"><span class="id" title="var">mactch</span></span> がどのように
徹底的な検索を可能にするかについてのエレガントなデモンストレーションを提供します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

ふたつの短い例で <span class="inlinecode"><span class="id" title="var">inster</span></span> の有効性を検証することができます。
組み込みの <span class="inlinecode"><span class="id" title="tactic">firstorder</span></span> タクティク（余計な引数なし）は、
最初のものを証明することができますが、2番目のものは証明できません。
  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="test_inster"><span class="id" title="section">test_inster</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="test_inster.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="test_inster.P"><span class="id" title="variable">P</span></a> <a name="test_inster.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="test_inster.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="test_inster.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="test_inster.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Match.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="test_inster"><span class="id" title="lemma">test_inster</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inster</span> 2.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="test_inster.H3"><span class="id" title="variable">H3</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>, <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="notation">≠</span> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="test_inster.H4"><span class="id" title="variable">H4</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">u</span>, <a class="idref" href="Cpdt.Match.html#test_inster.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="test_inster2"><span class="id" title="lemma">test_inster2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">≠</span> <a class="idref" href="Cpdt.Match.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#test_inster.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="Cpdt.Match.html#test_inster.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inster</span> 3.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#test_inster"><span class="id" title="section">test_inster</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">inster</span></span> の定義に採用されているスタイルは、関数的なプログラマーには直観に反するように見えます。
通常、関数プログラムは、明示的な状態変化を再帰関数にの引数に蓄積します。
Ltacでは、現在のサブゴールの状態は常に暗黙的です。
それにもかかわらず、一般的な命令型プログラミングとは対照的に、
この前の節最後の議論を思い出すなら、この状態への変更を元に戻すのは簡単です。
実際、このような「undo」は、<span class="inlinecode"><span class="id" title="keyword">match</span></span> 内の失敗で自動的に起こります。
このように、Ltacプログラミングは、<span class="inlinecode"><span class="id" title="tactic">first</span></span> タクティカルの行に沿って合成演算子(composition operator)
をサポートするステートフルな failure モナドを持つHaskellのプログラミングと似ています。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

関数プログラミングの純粋主義者は、
このようなプログラミングの提案に対して憤慨して反応するかもしれません。
それにもかかわらず、他の種類の「モナド・プログラミング」と同様に、
多くの問題が
MLやHaskellでの明示的で純粋な証明操作よりも、
Ltacで解決するのがはるかに簡単です。
実証するために、論理的含意いのための基本的な簡略化手順を書くことにします。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

この手順は、分離論理  に影響を受けています。
ここでは、式のなかの連言(conjuncts in formulas)は「リソース」と見なされ、
含意の両辺で等しい連言を「交差させる」ことによって完全性を失うことはありません。
このプロセスは、モジュール性の理由から、式が任意の入れ子ツリー構造（連言での分岐）を持つことができ、
存在量化子を含むことができるという事実によって複雑になります。
これは、マッチングプロセスが量化子を「下にいく」ことに役立ち、
実際に、存在量化子をどのように具体化するかを決定するのに役立ちます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

我々のタクティクが扱う含意を
さまざまな補題で「配管」として現れる含意から区別するために、
ラッパー定義、ノーテーション、およびタクティクを定義します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="imp"><span class="id" title="definition">imp</span></a> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> : <span class="id" title="keyword">Prop</span>) := <a class="idref" href="Cpdt.Match.html#P1"><span class="id" title="variable">P1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#P2"><span class="id" title="variable">P2</span></a>.<br/>
<span class="id" title="keyword">Infix</span> <a name="db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">&quot;</span></a>--&gt;" := <a class="idref" href="Cpdt.Match.html#imp"><span class="id" title="definition">imp</span></a> (<span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 95).<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">imp</span> := <span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.Match.html#imp"><span class="id" title="definition">imp</span></a>; <span class="id" title="tactic">firstorder</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#imp"><span class="id" title="definition">imp</span></a></span>に関するこれらの補題は、我々が書くタクティクに役立つでしょう。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="and_True_prem"><span class="id" title="lemma">and_True_prem</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <span class="id" title="inductive">True</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="and_True_conc"><span class="id" title="lemma">and_True_conc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <span class="id" title="inductive">True</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="pick_prem1"><span class="id" title="lemma">pick_prem1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="pick_prem2"><span class="id" title="lemma">pick_prem2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="comm_prem"><span class="id" title="lemma">comm_prem</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="pick_conc1"><span class="id" title="lemma">pick_conc1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="pick_conc2"><span class="id" title="lemma">pick_conc2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="comm_conc"><span class="id" title="lemma">comm_conc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちの <span class="inlinecode"><span class="id" title="var">matcher</span></span> タクティクを作る上での最初の作業(the first order of business)は、
式の木を検索するための補助的なサポートになります。
<span class="inlinecode"><span class="id" title="var">search_prem</span></span> タクティクは
<span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#imp"><span class="id" title="definition">imp</span></a></span> の前提のすべての部分式(subformula)で、引数<span class="inlinecode"><span class="id" title="var">tac</span></span>を実行するように実装されます。
木を走査するとき、<span class="inlinecode"><span class="id" title="var">search_prem</span></span> は上記の補題のいくつかを適用して、
異なる部分式(subformula)をゴールの頭部にもっていくことで、
ゴールを書き換えます。
すなわち、
その前提が、いくつかの<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>に対して、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>のかたちに再配置されるところで、
含意の前提のそれぞれの部分式 <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> に対して、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> を 「have a turn」しようとします。
タクティク <span class="inlinecode"><span class="id" title="var">tac</span></span> はこのかたちでゴールを見ることを期待し、
前提の最初の連言に注意を集中するでしょう。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">search_prem</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">search</span> <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">tac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#and_True_prem"><span class="id" title="lemma">and_True_prem</span></a>; <span class="id" title="var">tac</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="keyword">match</span> <span class="id" title="var">P</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">P2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#pick_prem1"><span class="id" title="lemma">pick_prem1</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#pick_prem2"><span class="id" title="lemma">pick_prem2</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">P</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="var">search</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">P</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#comm_prem"><span class="id" title="lemma">comm_prem</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">progress</span> (<span class="id" title="var">tac</span> || (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#and_True_prem"><span class="id" title="lemma">and_True_prem</span></a>; <span class="id" title="var">tac</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">search_prem</span></span> がどのように機能するかを理解するために、
最初に、最後の <span class="inlinecode"><span class="id" title="keyword">match</span></span> に進みます。
前提が連言で始まる場合は、各連言で<span class="inlinecode"><span class="id" title="var">search</span></span>手続きを呼び出します。 
<span class="inlinecode"><span class="id" title="var">search</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> の呼び出しは、ある <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> のための前提が <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> の形式であるという
不変性を期待し維持します。
<span class="inlinecode"><span class="id" title="var">tac</span></span>が常に失敗したときに永久にループするのを避けるために、
一種の再帰の尺度として減少する、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>を明示的に渡します。
2番目の<span class="inlinecode"><span class="id" title="keyword">match</span></span>の場合は、制御を<span class="inlinecode"><span class="id" title="var">search</span></span>に渡す前に、
この不変量を実現するために可換性(commutativity)の補題を呼び出します。
最終的な<span class="inlinecode"><span class="id" title="keyword">match</span></span> の場合では <span class="inlinecode"><span class="id" title="var">tac</span></span> を直接適用しようとしますが、
それが失敗すると、余分な<span class="inlinecode"><span class="id" title="inductive">True</span></span>結合を追加してゴールの形を変え、
<span class="inlinecode"><span class="id" title="var">tac</span></span>をもう一度呼び出します。
現在のサブゴールを変更せずに引数のタクティクが成功した場合、
<span class="inlinecode"><span class="id" title="tactic">progress</span></span> タクティカルは失敗します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">search</span></span> 関数自体は最後の <span class="inlinecode"><span class="id" title="keyword">match</span></span> の最後の場合と同じトリックを試みますが、
<span class="inlinecode">||</span>演算子を使ってひとつの手法を試してみます。
さらに、いずれも動作しない場合、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>が連言であるかどうかをチェックします。
そうであれば、それはそれぞれの連言に対して再帰的に自分自身を呼び出し、
最初に 結合性(associativity) と 可換性の補題を適用してゴールの式の不変性を維持します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

また、<span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#imp"><span class="id" title="definition">imp</span></a></span> の結論を通して木の検索を行う双対(dual)関数 <span class="inlinecode"><span class="id" title="var">search_conc</span></span> が必要です。 *）

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">search_conc</span> <span class="id" title="var">tac</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">search</span> <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">tac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#and_True_conc"><span class="id" title="lemma">and_True_conc</span></a>; <span class="id" title="var">tac</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="keyword">match</span> <span class="id" title="var">P</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">P2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#pick_conc1"><span class="id" title="lemma">pick_conc1</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#pick_conc2"><span class="id" title="lemma">pick_conc2</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> ?<span class="id" title="var">P</span> <span class="id" title="notation">∧</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="var">search</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="var">_</span> <span class="id" title="notation">∧</span> ?<span class="id" title="var">P</span> ] ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#comm_conc"><span class="id" title="lemma">comm_conc</span></a>; <span class="id" title="var">search</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">progress</span> (<span class="id" title="var">tac</span> || (<span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#and_True_conc"><span class="id" title="lemma">and_True_conc</span></a>; <span class="id" title="var">tac</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここでは、検索戦略によってアプリケーションに適したいくつかの補題を証明することができます。
前提を扱う補題は、<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>に関心をもった<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>の形式でなければならず、
結論を扱う補題は、<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>に関心をもった<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode">--&gt;</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a></span>の形式でなければなりません。

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="False_prem"><span class="id" title="lemma">False_prem</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;<span class="id" title="inductive">False</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="True_conc"><span class="id" title="lemma">True_conc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="inductive">True</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Match"><span class="id" title="lemma">Match</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ex_prem"><span class="id" title="lemma">ex_prem</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="Cpdt.Match.html#T"><span class="id" title="variable">T</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><span class="id" title="inductive">ex</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ex_conc"><span class="id" title="lemma">ex_conc</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="Cpdt.Match.html#T"><span class="id" title="variable">T</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>) <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="inductive">ex</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

取り消しが結論のすべての構成要素を取り除いた場合の証明を完成させるための
「基本ケース」補題も必要です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="imp_True"><span class="id" title="lemma">imp_True</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <span class="id" title="inductive">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">imp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

今や、最終的な<span class="inlinecode"><span class="id" title="var">matcher</span></span>タクティクは簡単です。
最初に、すべての変数をスコープに <span class="inlinecode"><span class="id" title="tactic">intro</span></span> し、
単純な前提の単純化を試み、
<span class="inlinecode"><span class="id" title="inductive">False</span></span>を見つけたら証明を完成させ、
見つかった存在量化子を取り除きます。
その後、結論を検索します。
<span class="inlinecode"><span class="id" title="inductive">True</span></span> の連言を取り除き、
ユニフィケーション変数を導入することによって、束縛変数のための存在量化子を取り除き、
一致する前提を探して取り除きます。
最後に、それ以上の進展がなければ、ゴールが自明かどうかをみて、
<span class="inlinecode"><a class="idref" href="Cpdt.Match.html#imp_True"><span class="id" title="lemma">imp_True</span></a></span> によって解くことができます。
それぞれの場合において、簡単にするために、<span class="inlinecode"><span class="id" title="tactic">apply</span></span> の代わりに、
より安価なユニフィケーション・アルゴリズムである
<span class="inlinecode"><span class="id" title="tactic">simple</span></span> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> タクティクを使います。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">matcher</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">search_prem</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">simple</span> <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#False_prem"><span class="id" title="lemma">False_prem</span></a> || (<span class="id" title="tactic">simple</span> <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#ex_prem"><span class="id" title="lemma">ex_prem</span></a>; <span class="id" title="tactic">intro</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">search_conc</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">simple</span> <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#True_conc"><span class="id" title="lemma">True_conc</span></a> || <span class="id" title="tactic">simple</span> <span class="id" title="tactic">eapply</span> <a class="idref" href="Cpdt.Match.html#ex_conc"><span class="id" title="lemma">ex_conc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="var">search_prem</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">simple</span> <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#Match"><span class="id" title="lemma">Match</span></a>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="tactic">simple</span> <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.Match.html#imp_True"><span class="id" title="lemma">imp_True</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちの戦術は簡単な例を証明するのに成功します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t2"><span class="id" title="lemma">t2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <span class="id" title="inductive">False</span><span class="id" title="notation">)</span> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">matcher</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
生成された証明では、検索手法の動作の痕跡が見つかります。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a> = <br/>
<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <span class="id" title="keyword">Prop</span> ⇒<br/>
<a class="idref" href="Cpdt.Match.html#comm_prem"><span class="id" title="lemma">comm_prem</span></a> (<a class="idref" href="Cpdt.Match.html#pick_prem1"><span class="id" title="lemma">pick_prem1</span></a> (<a class="idref" href="Cpdt.Match.html#pick_prem2"><span class="id" title="lemma">pick_prem2</span></a> (<a class="idref" href="Cpdt.Match.html#False_prem"><span class="id" title="lemma">False_prem</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>:=<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ∧ <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> ∧ (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ∧ <span class="id" title="inductive">False</span>) ∧ <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> --&gt; <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>


自動化が完了した後に人間の介入が必要な場合に<span class="inlinecode"><span class="id" title="var">matcher</span></span>が適していることがわかります。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t3"><span class="id" title="lemma">t3</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#R"><span class="id" title="variable">R</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">matcher</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">True</span> --&gt; <a class="idref" href="Cpdt.Large.html#slow.R"><span class="id" title="variable">R</span></a><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

私たちのタクティクは、それが取り消すことができたそれらの連言を取り消し、
<span class="inlinecode"><span class="id" title="tactic">intuition</span></span>と同じように、私たちのための簡略化されたサブゴールを残しました。 *）

<div class="paragraph"> </div>


</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">matcher</span></span> タクティクは、量化の具体化を推測することにも成功します。
実際の作業を行う <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#Match"><span class="id" title="lemma">Match</span></a></span> 補題の使用にあるのはユニフィケーションです。
  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t4"><span class="id" title="lemma">t4</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>) <span class="id" title="var">Q</span>, <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">(</span></a><span class="id" title="notation">∃</span> <span class="id" title="var">x</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">)</span></a> <a class="idref" href="Cpdt.Match.html#db9d5d46ef2ab5995e0c0739081666c1"><span class="id" title="notation">--&gt;</span></a> <a class="idref" href="Cpdt.Match.html#Q"><span class="id" title="variable">Q</span></a> <span class="id" title="notation">∧</span> <span class="id" title="notation">(</span><span class="id" title="notation">∃</span> <span class="id" title="var">x</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">matcher</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Cpdt.Match.html#t4"><span class="id" title="lemma">t4</span></a>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t4"><span class="id" title="lemma">t4</span></a> = <br/>
<span class="id" title="keyword">fun</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <span class="id" title="keyword">Prop</span>) (<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <span class="id" title="keyword">Prop</span>) ⇒<br/>
<a class="idref" href="Cpdt.Match.html#and_True_prem"><span class="id" title="lemma">and_True_prem</span></a><br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.Match.html#ex_prem"><span class="id" title="lemma">ex_prem</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>:=<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#pick_prem2"><span class="id" title="lemma">pick_prem2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Match.html#Match"><span class="id" title="lemma">Match</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>:=<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Match.html#and_True_conc"><span class="id" title="lemma">and_True_conc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Match.html#ex_conc"><span class="id" title="lemma">ex_conc</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x0</span> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <span class="id" title="var">x0</span>) <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Match.html#Match"><span class="id" title="lemma">Match</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>:=<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="Cpdt.Match.html#imp_True"><span class="id" title="lemma">imp_True</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>:=<span class="id" title="inductive">True</span>))))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <span class="id" title="keyword">Prop</span>) (<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> ∧ <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a>) --&gt; <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> ∧ (<span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

この証明の項はひと口で、手作業で構築していないのはうれしいことです！

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab83"></a><h1 class="section">ユニフィケーション変数の生成</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

タクティクを作成するための最後の有用な要素は、新しいユニフィケーション変数を明示的に割り当てることです。
<span class="inlinecode"><span class="id" title="tactic">eauto</span></span> のような戦術は、柔軟な証明検索をサポートするためにユニフィケーション変数を内部的に導入しています。
<span class="inlinecode"><span class="id" title="tactic">eauto</span></span> とその親戚は <i>後ろ向き</i> の推論をしていますが、 
ユニフィケーション変数が同様の理由で有用であるとき、しばしば同様に <i>前向き</i> 推論をしたいからです。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

例えば、全称定化された仮説の定化子を具体化するタクティクを書くことができます。
タクティクは、適切な具体化が何であるかを知る必要はありません。
むしろ、これらの選択肢は代用品(placeholder)で満たされています。
後で、特化するための(specialized)仮説を適用すると、構文的なユニフィケーションによって、
具体的な値が決まることを願っています。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

タクティクを書く準備が整う前に、一度にひとつずつ材料を試すことができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t5"><span class="id" title="lemma">t5</span></a> : <span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> 2 <span class="id" title="notation">&gt;</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> &gt; <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;2 &gt; 1<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

一般的に、<span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span>を具体化するには、最初に<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>に使用する値の名前を付ける必要があります。

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">evar</span> (<span class="id" title="var">y</span> : <span class="id" title="inductive">nat</span>).<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> &gt; <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> := ?279 : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;2 &gt; 1<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

証明コンテキストは新しい変数 <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> で拡張され、
新しいユニフィケーション変数 <span class="inlinecode">?279</span> と等しくなるように割り当てられています。
<span class="inlinecode">?279</span> と <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> を具体化する必要があります。
エイリアス <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> だけではなく、新しいユニフィケーション変数を取得するために、Ltac の
<span class="inlinecode"><span class="id" title="tactic">eval</span></span>
要素使用して式 <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> で自明な展開(unfolding)を実行します。
タクティク（例えば、<span class="inlinecode"><span class="id" title="tactic">simpl</span></span>、<span class="inlinecode"><span class="id" title="tactic">compute</span></span>など）で見られたのと同じ簡約戦略(reduction strategies)です。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">y'</span> := <span class="id" title="tactic">eval</span> <span class="id" title="tactic">unfold</span> <span class="id" title="var">y</span> <span class="id" title="keyword">in</span> <span class="id" title="var">y</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">y'</span>).<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> ?279 &gt; ?279<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;&nbsp;2 &gt; 1<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

具体化は成功しました。
<span class="inlinecode"><span class="id" title="tactic">apply</span></span> のユニフィケーションを使って <span class="inlinecode">?279</span> の固有な値を計算することで証明を終えることができます。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

今使っているパターンをカプセル化して、特定の仮説のすべての量化子を具体化する方法を書くことができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">insterU</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">T</span>, <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> "x" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">evar</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x'</span> := <span class="id" title="tactic">eval</span> <span class="id" title="tactic">unfold</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">x'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t5'"><span class="id" title="lemma">t5'</span></a> : <span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="Cpdt.Match.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> 2 <span class="id" title="notation">&gt;</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>; <span class="id" title="var">insterU</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この特定の例は、<span class="inlinecode"><span class="id" title="tactic">apply</span></span> 自体が本来の目的を達成していたので、やや馬鹿げています。
別の前方推論は、存在量化の定量化で終わる仮説により有用です。
例を見る前に、
私たちが渡すベースとなる仮説を除去(clear)していない <span class="inlinecode"><span class="id" title="var">insterU</span></span> の変種の Ltac の構成要素
<span class="inlinecode"><span class="id" title="tactic">fresh</span></span> を使用して、（引数の)文字列で示唆されるよい名前に基づいた、
まだ使用されていない仮説名を生成します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">insterKeep</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H'</span> := <span class="id" title="tactic">fresh</span> "H'" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">H'</span>; <span class="id" title="var">insterU</span> <span class="id" title="var">H'</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="t6"><span class="id" title="section">t6</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="t6.A"><span class="id" title="variable">A</span></a> <a name="t6.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t6.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.Match.html#t6.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t6.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Match.html#t6.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.A"><span class="id" title="variable">A</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t6.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Match.html#t6.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t6.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <span class="id" title="notation">∃</span> <span class="id" title="var">u</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t6.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t6.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">u1</span> <span class="id" title="var">v2</span> <span class="id" title="var">u2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t6.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t6.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t6.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t6.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="t6"><span class="id" title="lemma">t6</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span>, <span class="id" title="notation">∃</span> <span class="id" title="var">u1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t6.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t6.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t6.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">eauto</span></span> も <span class="inlinecode"><span class="id" title="tactic">firstorder</span></span> もこのゴールを証明するほどには賢くはありません。
量化子を使っていくつかの作業を自分で行い、<span class="inlinecode"><span class="id" title="tactic">do</span></span> タクティカルによって、
一定回数のタクティクを繰り返すことで、証明を省略します。
     
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 2 <span class="id" title="var">insterKeep</span> <a class="idref" href="Cpdt.Match.html#t6.H1"><span class="id" title="variable">H1</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

証明状態は<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span>のふたつの一般的なインスタンスで拡張されています。

<div class="paragraph"> </div>

       <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">H'</span> : <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ?4289 <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">H'0</span> : <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> ?4288 <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>)<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

通常の<span class="inlinecode"><span class="id" title="tactic">eauto</span></span>はまだ目標を証明することができませんので、
ふたつの新しい存在量化子を削除します。
（<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#ex"><span class="id" title="inductive">ex</span></a></span>は、<span class="inlinecode"><span class="id" title="tactic">∃</span></span>構文の使用がコンパイルされるもとになる型ファミリであることを思い出してください）
     
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="inductive">ex</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ゴールは、論理プログラミングで解くには、とても単純です。

</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#t6"><span class="id" title="section">t6</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">insterU</span></span> タクティクは、含意も含む量化仮説ではあまりうまくいきません。
最後の例をわずかに変更して問題を見ることができます。
新しい単項の述語<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>を導入し、仮説<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span>の追加の要求を表示するのに使います。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="t7"><span class="id" title="section">t7</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="t7.A"><span class="id" title="variable">A</span></a> <a name="t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t7.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t7.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">u1</span> <span class="id" title="var">v2</span> <span class="id" title="var">u2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t7.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="t7"><span class="id" title="lemma">t7</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span>, <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t7.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">do</span> 2 <span class="id" title="var">insterKeep</span> <a class="idref" href="Cpdt.Match.html#t7.H1"><span class="id" title="variable">H1</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="inductive">ex</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">eauto</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<pre>
No more subgoals but non-instantiated existential variables :
Existential 1 =
</pre>
       <br/>
<span class="inlinecode">?4384 : [<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> → <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> → <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.GeneralRec.html#Return.v"><span class="id" title="variable">v</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.GeneralRec.html#Return.v"><span class="id" title="variable">v</span></a> → <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.GeneralRec.html#Return.v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v1"><span class="id" title="variable">v1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H0</span> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H'</span> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a> → <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a> |- <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a>] 
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

別の存在変数(existential variable)についても同様の行があります。
ここで、「存在変数」とは、「ユニフィケーション変数」とも呼ばれるものを意味します。
証明の過程で、ユニフィケーション変数<span class="inlinecode">?4384</span>が導入されましたが、
ユニフィケーションされませんでした。
ユニフィケーション変数は、証明検索を構造化するための単なる器(device)です。
Gallina言語の証明項にはそれらが含まれていません。
したがって、変数を具体化せずに証明項を生成することはできません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

エラーメッセージは、<span class="inlinecode">?4384</span>が変数と仮説が表示されている特定の証明状態の
<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a></span>の証明であることを示しています。
それは<span class="inlinecode">?4384</span>が<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.H1"><span class="id" title="variable">H1</span></a></span>に渡す証明の値として<span class="inlinecode"><span class="id" title="var">insterU</span></span>によって作成されたことが判明しました。
Gallinaでは、含意は単に<span class="inlinecode"><span class="id" title="keyword">∀</span></span>量化の縮退したかたちであるため、
<span class="inlinecode"><span class="id" title="keyword">∀</span></span>と一致させる<span class="inlinecode"><span class="id" title="var">insterU</span></span>コードもこの含意と一致したことを思い出してください。
この文脈で<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#v2"><span class="id" title="variable">v2</span></a></span>の証明は他の証明と同じくらい良いので、
どの証明が適切かを正確に判断するためにユニフィケーションを使う機会は決してありません。
同様に<span class="inlinecode"><span class="id" title="var">insterU</span></span>の引数にある含意の問題を予期しています。
     
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Abort</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#t7"><span class="id" title="section">t7</span></a>.<br/>

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">insterU</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode">?<a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a>,</span> <span class="inlinecode">...</span>の型<span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span>の型をパターンマッチさせる<span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span>に型<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>、
<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>の具体化は証明のために考える必要があります。
したがって、新しい統一変数を選択するのではなく、
ユーザーが指定した戦術<span class="inlinecode"><span class="id" title="var">tac</span></span>を適用します。
<span class="inlinecode"><span class="id" title="var">tac</span></span>が<span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span>を証明するのに失敗した場合、
デフォルトの量化の処理を続けるのではなく、
具体化を中止します。また、

が目標を完全に解決しない場合、<span class="inlinecode"><span class="id" title="tactic">solve</span></span> <span class="inlinecode">[<a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>]</span> は失敗します。*）
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">insterU</span> <span class="id" title="var">tac</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">T</span>, <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">T</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Prop</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">let</span> <span class="id" title="var">H'</span> := <span class="id" title="tactic">fresh</span> "H'" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <span class="id" title="var">T</span>) <span class="id" title="tactic">by</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="var">tac</span> ];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">H'</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">H'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id" title="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">fresh</span> "x" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">evar</span> (<span class="id" title="var">x</span> : <span class="id" title="var">T</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x'</span> := <span class="id" title="tactic">eval</span> <span class="id" title="tactic">unfold</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">x'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">insterKeep</span> <span class="id" title="var">tac</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H'</span> := <span class="id" title="tactic">fresh</span> "H'" <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">H'</span>; <span class="id" title="var">insterU</span> <span class="id" title="var">tac</span> <span class="id" title="var">H'</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="t7"><span class="id" title="section">t7</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="t7.A"><span class="id" title="variable">A</span></a> <a name="t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.A"><span class="id" title="variable">A</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="t7.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t7.H1"><span class="id" title="variable">H1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Cpdt.Match.html#u"><span class="id" title="variable">u</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <a name="t7.H2"><span class="id" title="variable">H2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">u1</span> <span class="id" title="var">v2</span> <span class="id" title="var">u2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t7.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="t7"><span class="id" title="lemma">t7</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span>, <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">u2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Cpdt.Match.html#t7.f"><span class="id" title="variable">f</span></a> <a class="idref" href="Cpdt.Match.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="Cpdt.Match.html#v2"><span class="id" title="variable">v2</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.Match.html#u1"><span class="id" title="variable">u1</span></a> <a class="idref" href="Cpdt.Match.html#u2"><span class="id" title="variable">u2</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

まだ<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>の事実を知らない変数について<span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>仮説を見つけて適用しようとするタクティクで
<span class="inlinecode"><span class="id" title="var">insterKeep</span></span>を呼び出すことによってゴールを証明することができます。
Coqの証明エンジンで、
ファーストクラスのタクティクの引数が、
<span class="inlinecode"><span class="id" title="keyword">match</span></span>で始まらなければならないという奇妙な制限を回避するために、
このタクティクのコードを<span class="inlinecode"><span class="id" title="tactic">idtac</span>;</span> <span class="inlinecode"></span>で始める必要があります。
     
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">do</span> 2 <span class="id" title="var">insterKeep</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">idtac</span>; <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="Cpdt.Match.html#t7.Q"><span class="id" title="variable">Q</span></a> ?<span class="id" title="var">v</span> |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.Match.html#t7.P"><span class="id" title="variable">P</span></a> <span class="id" title="var">v</span> <span class="id" title="var">_</span>] |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">fail</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.Match.html#t7.H1"><span class="id" title="variable">H1</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="inductive">ex</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Match.html#t7"><span class="id" title="section">t7</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

存在変数(existential variables)を明示的に具体化することはしばしば役に立ちます。
組み込みタクティクはそれをするひとつの方法を提供します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t8"><span class="id" title="lemma">t8</span></a> : <span class="id" title="notation">∃</span> <span class="id" title="var">p</span> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">×</span> <span class="id" title="inductive">nat</span><span class="id" title="notation">,</span> <span class="id" title="definition">fst</span> <a class="idref" href="Cpdt.Match.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">=</span> 3.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">instantiate</span> (1 := <span class="id" title="notation">(</span>3<span class="id" title="notation">,</span> 2<span class="id" title="notation">)</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

上記の<span class="inlinecode">1</span>は、現在のゴールに現れる存在変数を特定するもので、
最後に存在するものが番号1に割り当てられ、2番目に割り当てられた番号2が割り当てられます。
名前のついた存在（変数）は、どこでも<span class="inlinecode">:=</span>の右側の項に置き換えられます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">instantiate</span></span> タクティクは
探索的な証明(exploratory proving)のためには便利かもしれませんが、
変化する定理には適応しにくい非常に脆い証明スクリプトにつながります。
実在すると判っている項に値を割り当てるために使用できるタクティクを持つことは、しばしば有用です。
婉曲な(roundabout)実装技術を採用することで、この機能を一般化するタクティクを作ることができます。
特に、我々の戦術<span class="inlinecode"><span class="id" title="var">equate</span></span>は、2つの項が等しいことを主張します。
項のひとつが存在していれば、それはどこにでも置き換えられます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">equate</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">dummy</span> := <span class="id" title="keyword">constr</span>:(<span class="id" title="constructor">eq_refl</span> <span class="id" title="var">x</span> : <span class="id" title="var">x</span> <span class="id" title="notation">=</span> <span class="id" title="var">y</span>) <span class="id" title="keyword">in</span> <span class="id" title="tactic">idtac</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a></span>で<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>を証明することができない場合、この方法は失敗します。
関連する変数<span class="inlinecode"><span class="id" title="var">dummy</span></span>を無視して、ユニフィケーションの副作用のみをチェックします。
<span class="inlinecode"><span class="id" title="var">equate</span></span> によって先の例の脆弱なバージョンを作ることができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="t9"><span class="id" title="lemma">t9</span></a> : <span class="id" title="notation">∃</span> <span class="id" title="var">p</span> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">×</span> <span class="id" title="inductive">nat</span><span class="id" title="notation">,</span> <span class="id" title="definition">fst</span> <a class="idref" href="Cpdt.Match.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">=</span> 3.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span>; <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="definition">fst</span> ?<span class="id" title="var">x</span> <span class="id" title="notation">=</span> 3 ] ⇒ <span class="id" title="var">equate</span> <span class="id" title="var">x</span> <span class="id" title="notation">(</span>3<span class="id" title="notation">,</span> 2<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このテクニックは、
広範囲のゴールを解決するための再帰な繰り返しのあるタクティクの中でさらに役立ちます。
 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>