<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.Equality</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.Equality</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 In traditional mathematics, the concept of equality is usually taken as a given.  On the other hand, in type theory, equality is a very contentious subject.  There are at least three different notions of equality that are important in Coq, and researchers are actively investigating new definitions of what it means for two terms to be equal.  Even once we fix a notion of equality, there are inevitably tricky issues that arise in proving properties of programs that manipulate equality proofs explicitly.  In this chapter, I will focus on design patterns for circumventing these tricky issues, and I will introduce the different notions of equality as they are germane. 
<div class="paragraph"> </div>

<a name="lab63"></a><h1 class="section">The Definitional Equality</h1>

<div class="paragraph"> </div>

 We have seen many examples so far where proof goals follow "by computation."  That is, we apply computational reduction rules to reduce the goal to a normal form, at which point it follows trivially.  Exactly when this works and when it does not depends on the details of Coq's <i>definitional equality</i>.  This is an untyped binary relation appearing in the formal metatheory of CIC.  CIC contains a typing rule allowing the conclusion <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> from the premise <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#map.T'"><span class="id" title="variable">T'</span></a></span> and a proof that <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#map.T'"><span class="id" title="variable">T'</span></a></span> are definitionally equal.

<div class="paragraph"> </div>

   The <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> tactic will help us illustrate the rules of Coq's definitional equality.  We redefine the natural number predecessor function in a somewhat convoluted way and construct a manual proof that it returns <span class="inlinecode">0</span> when applied to <span class="inlinecode">1</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="pred'"><span class="id" title="definition">pred'</span></a> (<span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="constructor">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="keyword">let</span> <span class="id" title="var">y</span> := <span class="id" title="var">n'</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Equality.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="reduce_me"><span class="id" title="lemma">reduce_me</span></a> : <a class="idref" href="Cpdt.Equality.html#pred'"><span class="id" title="definition">pred'</span></a> 1 <span class="id" title="notation">=</span> 0.<br/>

<br/>
</div>

<div class="doc">
CIC follows the traditions of lambda calculus in associating reduction rules with Greek letters.  Coq can certainly be said to support the familiar alpha reduction rule, which allows capture-avoiding renaming of bound variables, but we never need to apply alpha explicitly, since Coq uses a de Bruijn representation that encodes terms canonically.

<div class="paragraph"> </div>

     The delta rule is for unfolding global definitions.  We can use it here to unfold the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#pred'"><span class="id" title="definition">pred'</span></a></span>.  We do this with the <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> tactic, which takes a list of reduction rules and makes as many call-by-value reduction steps as possible, using only those rules.  There is an analogous tactic <span class="inlinecode"><span class="id" title="tactic">lazy</span></span> for call-by-need reduction. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> ⇒ <span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> := <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) 1 = 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

      At this point, we want to apply the famous beta reduction of lambda calculus, to simplify the application of a known function abstraction. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> 1 <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| 0 ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> ⇒ <span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> := <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> = 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   Next on the list is the iota reduction, which simplifies a single <span class="inlinecode"><span class="id" title="keyword">match</span></span> term by determining which pattern matches. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> := <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>) 0 = 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   Now we need another beta reduction. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> := 0 <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>) = 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

      The final reduction rule is zeta, which replaces a <span class="inlinecode"><span class="id" title="keyword">let</span></span> expression by its body with the appropriate term substituted. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">zeta</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;0 = 0
<div class="paragraph"> </div>

</span>   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="keyword">beta</span></span> reduction rule applies to recursive functions as well, and its behavior may be surprising in some instances.  For instance, we can run some simple tests using the reduction strategy <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, which applies all applicable rules of the definitional equality. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="id"><span class="id" title="definition">id</span></a> (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) := <a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.Equality.html#id"><span class="id" title="definition">id</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="id'"><span class="id" title="definition">id'</span></a> (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) := <a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Cpdt.Equality.html#id'"><span class="id" title="definition">id'</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ (<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.Equality.html#id'"><span class="id" title="definition">id'</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> := <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

By running <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, we ask Coq to run reduction steps until no more apply, so why do we see an application of a known function, where clearly no beta reduction has been performed?  The answer has to do with ensuring termination of all Gallina programs.  One candidate rule would say that we apply recursive definitions wherever possible.  However, this would clearly lead to nonterminating reduction sequences, since the function may appear fully applied within its own definition, and we would naively "simplify" such applications immediately.  Instead, Coq only applies the beta rule for a recursive function when <i>the top-level structure of the recursive argument is known</i>.  For <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#id'"><span class="id" title="definition">id'</span></a></span> above, we have only one argument <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>, so clearly it is the recursive argument, and the top-level structure of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> is known when the function is applied to <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#O"><span class="id" title="constructor">O</span></a></span> or to some <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> term.  The variable <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> is neither, so reduction is blocked.

<div class="paragraph"> </div>

What are recursive arguments in general?  Every recursive function is compiled by Coq to a <span class="inlinecode"><span class="id" title="keyword">fix</span></span> expression, for anonymous definition of recursive functions.  Further, every <span class="inlinecode"><span class="id" title="keyword">fix</span></span> with multiple arguments has one designated as the recursive argument via a <span class="inlinecode"><span class="id" title="keyword">struct</span></span> annotation.  The recursive argument is the one that must decrease across recursive calls, to appease Coq's termination checker.  Coq will generally infer which argument is recursive, though we may also specify it manually, if we want to tweak reduction behavior.  For instance, consider this definition of a function to add two lists of <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>s elementwise: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="addLists"><span class="id" title="definition">addLists</span></a> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat</span>) : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a>, <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">n1</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls1'</span> , <span class="id" title="var">n2</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls2'</span> ⇒ <span class="id" title="var">n1</span> <span class="id" title="notation">+</span> <span class="id" title="var">n2</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
By default, Coq chooses <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a></span> as the recursive argument.  We can see that <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a></span> would have been another valid choice.  The choice has a critical effect on reduction behavior, as these two examples illustrate: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">ls</span> ⇒ <a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a> <span class="id" title="constructor">nil</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <span class="id" title="constructor">nil</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">ls</span> ⇒ <a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="constructor">nil</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.InductiveTypes.html#n1"><span class="id" title="variable">n1</span></a> :: <span class="id" title="var">ls1'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.InductiveTypes.html#n2"><span class="id" title="variable">n2</span></a> :: <span class="id" title="var">ls2'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.InductiveTypes.html#plus"><span class="id" title="definition">plus</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.InductiveTypes.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#n2"><span class="id" title="variable">n2</span></a> :: <a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="constructor">nil</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The outer application of the <span class="inlinecode"><span class="id" title="keyword">fix</span></span> expression for <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a></span> was only simplified in the first case, because in the second case the recursive argument is <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a></span>, whose top-level structure is not known.

<div class="paragraph"> </div>

The opposite behavior pertains to a version of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#addLists"><span class="id" title="definition">addLists</span></a></span> with <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a></span> marked as recursive. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="addLists'"><span class="id" title="definition">addLists'</span></a> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat</span>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">ls2</span>} : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a>, <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">n1</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls1'</span> , <span class="id" title="var">n2</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls2'</span> ⇒ <span class="id" title="var">n1</span> <span class="id" title="notation">+</span> <span class="id" title="var">n2</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.Equality.html#addLists'"><span class="id" title="definition">addLists'</span></a> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">ls</span> ⇒ <a class="idref" href="Cpdt.Equality.html#addLists'"><span class="id" title="definition">addLists'</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="constructor">nil</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> :: <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We see that all use of recursive functions has been eliminated, though the term has not quite simplified to <span class="inlinecode"><span class="id" title="constructor">nil</span></span>.  We could get it to do so by switching the order of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> discriminees in the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#addLists'"><span class="id" title="definition">addLists'</span></a></span>.

<div class="paragraph"> </div>

Recall that co-recursive definitions have a dual rule: a co-recursive call only simplifies when it is the discriminee of a <span class="inlinecode"><span class="id" title="keyword">match</span></span>.  This condition is built into the beta rule for <span class="inlinecode"><span class="id" title="keyword">cofix</span></span>, the anonymous form of <span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span></span>.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

   The standard <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> relation is critically dependent on the definitional equality.  The relation <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> is often called a <i>propositional equality</i>, because it reifies definitional equality as a proposition that may or may not hold.  Standard axiomatizations of an equality predicate in first-order logic define equality in terms of properties it has, like reflexivity, symmetry, and transitivity.  In contrast, for <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> in Coq, those properties are implicit in the properties of the definitional equality, which are built into CIC's metatheory and the implementation of Gallina.  We could add new rules to the definitional equality, and <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> would keep its definition and methods of use.

<div class="paragraph"> </div>

   This all may make it sound like the choice of <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span>'s definition is unimportant.  To the contrary, in this chapter, we will see examples where alternate definitions may simplify proofs.  Before that point, I will introduce proof methods for goals that use proofs of the standard propositional equality "as data." 
<div class="paragraph"> </div>

<a name="lab64"></a><h1 class="section">Heterogeneous Lists Revisited</h1>

<div class="paragraph"> </div>

 One of our example dependent data structures from the last chapter (code repeated below) was the heterogeneous list and its associated "cursor" type.  The recursive version poses some special challenges related to equality proofs, since it uses such proofs in its definition of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fmember"><span class="id" title="definition">fmember</span></a></span> types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="fhlist"><span class="id" title="section">fhlist</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhlist.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhlist.B"><span class="id" title="variable">B</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="fhlist"><span class="id" title="definition">fhlist</span></a> (<span class="id" title="var">ls</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Equality.html#fhlist.A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="inductive">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls'</span> ⇒ <a class="idref" href="Cpdt.Equality.html#fhlist.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">x</span> <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <span class="id" title="var">ls'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>%<span class="id" title="var">type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhlist.elm"><span class="id" title="variable">elm</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist.A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="fmember"><span class="id" title="definition">fmember</span></a> (<span class="id" title="var">ls</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Equality.html#fhlist.A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="inductive">Empty_set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls'</span> ⇒ <span class="id" title="notation">(</span><span class="id" title="var">x</span> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#fhlist.elm"><span class="id" title="variable">elm</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.Equality.html#fmember"><span class="id" title="definition">fmember</span></a> <span class="id" title="var">ls'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>%<span class="id" title="var">type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="fhget"><span class="id" title="definition">fhget</span></a> (<span class="id" title="var">ls</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Equality.html#fhlist.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fmember"><span class="id" title="definition">fmember</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist.elm"><span class="id" title="variable">elm</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fmember"><span class="id" title="definition">fmember</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist.elm"><span class="id" title="variable">elm</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">idx</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#idx"><span class="id" title="variable">idx</span></a> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> <span class="id" title="var">ls'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">mls</span> <span class="id" title="var">idx</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#idx"><span class="id" title="variable">idx</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">inl</span> <span class="id" title="var">pf</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="definition">fst</span> <a class="idref" href="Cpdt.Equality.html#mls"><span class="id" title="variable">mls</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">inr</span> <span class="id" title="var">idx'</span> ⇒ <a class="idref" href="Cpdt.Equality.html#fhget"><span class="id" title="definition">fhget</span></a> <span class="id" title="var">ls'</span> (<span class="id" title="definition">snd</span> <a class="idref" href="Cpdt.Equality.html#mls"><span class="id" title="variable">mls</span></a>) <span class="id" title="var">idx'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="section">fhlist</span></a>.<br/>

<br/>
<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.Equality.html#fhget"><span class="id" title="definition">fhget</span></a> [<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">elm</span> <span class="id" title="var">ls</span>].<br/>

<br/>

<br/>
</div>

<div class="doc">
We can define a <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#map"><span class="id" title="definition">map</span></a></span>-like function for <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="fhlist_map"><span class="id" title="section">fhlist_map</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="fhlist_map.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="fhlist_map.B"><span class="id" title="variable">B</span></a> <a name="fhlist_map.C"><span class="id" title="variable">C</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhlist_map.f"><span class="id" title="variable">f</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="Cpdt.Equality.html#fhlist_map.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="fhmap"><span class="id" title="definition">fhmap</span></a> (<span class="id" title="var">ls</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">tt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">hls</span> ⇒ <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Equality.html#fhlist_map.f"><span class="id" title="variable">f</span></a> (<span class="id" title="definition">fst</span> <a class="idref" href="Cpdt.Equality.html#hls"><span class="id" title="variable">hls</span></a>)<span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Equality.html#fhmap"><span class="id" title="definition">fhmap</span></a> <span class="id" title="var">_</span> (<span class="id" title="definition">snd</span> <a class="idref" href="Cpdt.Equality.html#hls"><span class="id" title="variable">hls</span></a>)<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.Equality.html#fhmap"><span class="id" title="definition">fhmap</span></a> [<span class="id" title="var">ls</span>].<br/>

<br/>

<br/>
</div>

<div class="doc">
For the inductive versions of the <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span> definitions, we proved a lemma about the interaction of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#get"><span class="id" title="definition">get</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#imap"><span class="id" title="definition">imap</span></a></span>.  It was a strategic choice not to attempt such a proof for the definitions that we just gave, which sets us on a collision course with the problems that are the subject of this chapter. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhlist_map.elm"><span class="id" title="variable">elm</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fhget_fhmap"><span class="id" title="lemma">fhget_fhmap</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ls</span> (<span class="id" title="var">mem</span> : <a class="idref" href="Cpdt.Equality.html#fmember"><span class="id" title="definition">fmember</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a>) (<span class="id" title="var">hls</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhlist_map.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhget"><span class="id" title="definition">fhget</span></a> (<a class="idref" href="Cpdt.Equality.html#fhmap"><span class="id" title="definition">fhmap</span></a> <a class="idref" href="Cpdt.Equality.html#hls"><span class="id" title="variable">hls</span></a>) <a class="idref" href="Cpdt.Equality.html#mem"><span class="id" title="variable">mem</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map.f"><span class="id" title="variable">f</span></a> (<a class="idref" href="Cpdt.Equality.html#fhget"><span class="id" title="definition">fhget</span></a> <a class="idref" href="Cpdt.Equality.html#hls"><span class="id" title="variable">hls</span></a> <a class="idref" href="Cpdt.Equality.html#mem"><span class="id" title="variable">mem</span></a>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

    In Coq 8.2, one subgoal remains at this point.  Coq 8.3 has added some tactic improvements that enable <span class="inlinecode"><span class="id" title="var">crush</span></span> to complete all of both inductive cases.  To introduce the basics of reasoning about equality, it will be useful to review what was necessary in Coq 8.2.

<div class="paragraph"> </div>

       Part of our single remaining subgoal is:
       <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">a0</span> : <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> = <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">a0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <span class="id" title="var">a2</span>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a> <span class="id" title="var">a2</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <span class="id" title="var">a1</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> = <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <span class="id" title="keyword">match</span> <span class="id" title="var">a0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <span class="id" title="var">a2</span>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">a2</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <span class="id" title="var">a1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   This seems like a trivial enough obligation.  The equality proof <span class="inlinecode"><span class="id" title="var">a0</span></span> must be <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a></span>, the only constructor of <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span>.  Therefore, both the <span class="inlinecode"><span class="id" title="keyword">match</span></span>es reduce to the point where the conclusion follows by reflexivity.
    <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a0</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: Cannot solve a second-order unification problem
</pre>

<div class="paragraph"> </div>

    This is one of Coq's standard error messages for informing us of a failure in its heuristics for attempting an instance of an undecidable problem about dependent typing.  We might try to nudge things in the right direction by stating the lemma that we believe makes the conclusion trivial.
    <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">a0</span> = <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> <span class="id" title="var">_</span>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
The term "eq_refl ?98" has type "?98 = ?98"
 while it is expected to have type "a = elm"
</pre>

<div class="paragraph"> </div>

    In retrospect, the problem is not so hard to see.  Reflexivity proofs only show <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> for particular values of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>, whereas here we are thinking in terms of a proof of <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a></span>, where the two sides of the equality are not equal syntactically.  Thus, the essential lemma we need does not even type-check!

<div class="paragraph"> </div>

    Is it time to throw in the towel?  Luckily, the answer is "no."  In this chapter, we will see several useful patterns for proving obligations like this.

<div class="paragraph"> </div>

    For this particular example, the solution is surprisingly straightforward.  The <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> tactic has a simpler sibling <span class="inlinecode"><span class="id" title="tactic">case</span></span> which should behave identically for any inductive type with one constructor of no arguments.
    <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a0</span>.<br/>
<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <span class="id" title="var">a1</span> = <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <span class="id" title="var">a1</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

    It seems that <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> was trying to be too smart for its own good.
    <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It will be helpful to examine the proof terms generated by this sort of strategy.  A simpler example illustrates what is going on. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="lemma1"><span class="id" title="lemma">lemma1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a>), <span class="id" title="constructor">O</span> <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">O</span> <span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">pf</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="tactic">simple</span></span> <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> is a convenient form for applying <span class="inlinecode"><span class="id" title="tactic">case</span></span>.  It runs <span class="inlinecode"><span class="id" title="tactic">intro</span></span> to bring into scope all quantified variables up to its argument. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <a class="idref" href="Cpdt.Equality.html#lemma1"><span class="id" title="lemma">lemma1</span></a>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#lemma1"><span class="id" title="lemma">lemma1</span></a> = <br/>
<span class="id" title="keyword">fun</span> (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a>) ⇒<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">as</span> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="keyword">return</span> (0 = <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="keyword">with</span><br/>
| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> 0<br/>
<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a>), 0 = <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

    Using what we know about shorthands for <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations, we can write this proof in shorter form manually. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="lemma1'"><span class="id" title="definition">lemma1'</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map.elm"><span class="id" title="variable">elm</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">return</span> (0 <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">eq_refl</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Surprisingly, what seems at first like a <i>simpler</i> lemma is harder to prove. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="lemma2"><span class="id" title="lemma">lemma2</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>), <span class="id" title="constructor">O</span> <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">O</span> <span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">destruct</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: Cannot solve a second-order unification problem
</pre>
      
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nonetheless, we can adapt the last manual proof to handle this theorem. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="lemma2"><span class="id" title="definition">lemma2</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">return</span> (0 <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">eq_refl</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can try to prove a lemma that would simplify proofs of many facts like <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#lemma2"><span class="id" title="definition">lemma2</span></a></span>: 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="lemma3"><span class="id" title="lemma">lemma3</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>), <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="notation">=</span> <span class="id" title="constructor">eq_refl</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">destruct</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: Cannot solve a second-order unification problem
</pre>
      
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
This time, even our manual attempt fails.
     <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.Equality.html#lemma3'"><span class="id" title="definition">lemma3'</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">as</span> <span class="id" title="var">pf'</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.GeneralRec.html#x'"><span class="id" title="variable">x'</span></a>) <span class="id" title="keyword">return</span> (<span class="id" title="var">pf'</span> = <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> <a class="idref" href="Cpdt.GeneralRec.html#x'"><span class="id" title="variable">x'</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
The term "eq_refl x'" has type "x' = x'" while it is expected to have type
 "x = x'"
</pre>

<div class="paragraph"> </div>

     The type error comes from our <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation.  In that annotation, the <span class="inlinecode"><span class="id" title="keyword">as</span></span>-bound variable <span class="inlinecode"><span class="id" title="var">pf'</span></span> has type <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#x'"><span class="id" title="variable">x'</span></a></span>, referring to the <span class="inlinecode"><span class="id" title="keyword">in</span></span>-bound variable <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#x'"><span class="id" title="variable">x'</span></a></span>.  To do a dependent <span class="inlinecode"><span class="id" title="keyword">match</span></span>, we <i>must</i> choose a fresh name for the second argument of <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span>.  We are just as constrained to use the "real" value <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> for the first argument.  Thus, within the <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause, the proof we are matching on <i>must</i> equate two non-matching terms, which makes it impossible to equate that proof with reflexivity.

<div class="paragraph"> </div>

     Nonetheless, it turns out that, with one catch, we <i>can</i> prove this lemma. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="lemma3"><span class="id" title="lemma">lemma3</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#fhlist_map.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>), <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="notation">=</span> <span class="id" title="constructor">eq_refl</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <span class="id" title="lemma">UIP_refl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="lemma">UIP_refl</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">UIP_refl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>), <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> = <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     The theorem <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span> comes from the <span class="inlinecode"><span class="id" title="library">Eqdep</span></span> module of the standard library.  (Its name uses the acronym "UIP" for "unicity of identity proofs.")  Do the Coq authors know of some clever trick for building such proofs that we have not seen yet?  If they do, they did not use it for this proof.  Rather, the proof is based on an <i>axiom</i>, the term <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span> below. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="axiom">eq_rect_eq</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">*** [ <span class="id" title="axiom">eq_rect_eq</span> : <br/>
<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a>) (<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> → <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> : <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> = <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>),<br/>
<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <span class="id" title="definition">eq_rect</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> ]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

      The axiom <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span> states a "fact" that seems like common sense, once the notation is deciphered.  The term <span class="inlinecode"><span class="id" title="definition">eq_rect</span></span> is the automatically generated recursion principle for <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span>.  Calling <span class="inlinecode"><span class="id" title="definition">eq_rect</span></span> is another way of <span class="inlinecode"><span class="id" title="keyword">match</span></span>ing on an equality proof.  The proof we match on is the argument <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a></span>, and <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> is the body of the <span class="inlinecode"><span class="id" title="keyword">match</span></span>.  The statement of <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span> just says that <span class="inlinecode"><span class="id" title="keyword">match</span></span>es on proofs of <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a></span>, for any <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a></span>, are superfluous and may be removed.  We can see this intuition better in code by asking Coq to simplify the theorem statement with the <span class="inlinecode"><span class="id" title="tactic">compute</span></span> reduction strategy. 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="keyword">∀</span> (<span class="id" title="var">U</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a>) (<span class="id" title="var">Q</span> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Equality.html#p"><span class="id" title="variable">p</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="Cpdt.Equality.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#p"><span class="id" title="variable">p</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <span class="id" title="definition">eq_rect</span> <a class="idref" href="Cpdt.Equality.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.Equality.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Equality.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.Equality.html#h"><span class="id" title="variable">h</span></a>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a>) (<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> → <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> : <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> = <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     Perhaps surprisingly, we cannot prove <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span> from within Coq.  This proposition is introduced as an axiom; that is, a proposition asserted as true without proof.  We cannot assert just any statement without proof.  Adding <span class="inlinecode"><span class="id" title="inductive">False</span></span> as an axiom would allow us to prove any proposition, for instance, defeating the point of using a proof assistant.  In general, we need to be sure that we never assert <i>inconsistent</i> sets of axioms.  A set of axioms is inconsistent if its conjunction implies <span class="inlinecode"><span class="id" title="inductive">False</span></span>.  For the case of <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span>, consistency has been verified outside of Coq via "informal" metatheory, in a study that also established unprovability of the axiom in CIC.

<div class="paragraph"> </div>

      This axiom is equivalent to another that is more commonly known and mentioned in type theory circles. 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="lemma">Streicher_K</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">Streicher_K</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> → <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  This is the opaquely named "Streicher's axiom K," which says that a predicate on properly typed equality proofs holds of all such proofs if it holds of reflexivity. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Equality.html#fhlist_map"><span class="id" title="section">fhlist_map</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
It is worth remarking that it is possible to avoid axioms altogether for equalities on types with decidable equality.  The <span class="inlinecode"><span class="id" title="library">Eqdep_dec</span></span> module of the standard library contains a parametric proof of <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span> for such cases.  To simplify presentation, we will stick with the axiom version in the rest of this chapter. 
<div class="paragraph"> </div>

<a name="lab65"></a><h1 class="section">Type-Casts in Theorem Statements</h1>

<div class="paragraph"> </div>

 Sometimes we need to use tricks with equality just to state the theorems that we care about.  To illustrate, we start by defining a concatenation function for <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="fhapp"><span class="id" title="section">fhapp</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp.B"><span class="id" title="variable">B</span></a> : <a class="idref" href="Cpdt.Equality.html#fhapp.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="fhapp"><span class="id" title="definition">fhapp</span></a> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.Equality.html#fhapp.A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">hls2</span> ⇒ <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> <span class="id" title="notation">::</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">hls1</span> <span class="id" title="var">hls2</span> ⇒ <span class="id" title="notation">(</span><span class="id" title="definition">fst</span> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="definition">snd</span> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> [<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>].<br/>

<br/>

<br/>
</div>

<div class="doc">
We might like to prove that <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> is associative.
     <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a class="idref" href="Cpdt.Equality.html#fhapp_assoc"><span class="id" title="lemma">fhapp_assoc</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>) = <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
The term
 "fhapp (ls1:=ls1 ++ ls2) (ls2:=ls3) (fhapp (ls1:=ls1) (ls2:=ls2) hls1 hls2)
    hls3" has type "fhlist B ((ls1 ++ ls2) ++ ls3)"
 while it is expected to have type "fhlist B (ls1 ++ ls2 ++ ls3)"
</pre>

<div class="paragraph"> </div>

     This first cut at the theorem statement does not even type-check.  We know that the two <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a></span> types appearing in the error message are always equal, by associativity of normal list append, but this fact is not apparent to the type checker.  This stems from the fact that Coq's equality is <i>intensional</i>, in the sense that type equality theorems can never be applied after the fact to get a term to type-check.  Instead, we need to make use of equality explicitly in the theorem statement. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fhapp_assoc"><span class="id" title="lemma">fhapp_assoc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls3</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">pf</span> : <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="notation">++</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a><span class="id" title="notation">)</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hls1</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a>) (<span class="id" title="var">hls2</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a>) (<span class="id" title="var">hls3</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> <span class="id" title="notation">=</span> <span class="id" title="var">ls</span>) <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Equality.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
The first remaining subgoal looks trivial enough:
       <br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

       We can try what worked in previous examples.
       <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: Cannot solve a second-order unification problem
</pre>

<div class="paragraph"> </div>

        It seems we have reached another case where it is unclear how to use a dependent <span class="inlinecode"><span class="id" title="keyword">match</span></span> to implement case analysis on our proof.  The <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span> theorem can come to our rescue again. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">UIP_refl</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">pf</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>
<div class="paragraph"> </div>

</span>        
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
Our second subgoal is trickier.
       <br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">UIP_refl</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
The term "pf" has type "a :: (ls1 ++ ls2) ++ ls3 = a :: ls1 ++ ls2 ++ ls3"
 while it is expected to have type "?556 = ?556"
</pre>

<div class="paragraph"> </div>

       We can only apply <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span> on proofs of equality with syntactically equal operands, which is not the case of <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> here.  We will need to manipulate the form of this subgoal to get us to a point where we may use <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span>.  A first step is obtaining a proof suitable to use in applying the induction hypothesis.  Inversion on the structure of <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> is sufficient for that. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">injection</span> <span class="id" title="var">pf</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">pf'</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">pf'</span> : (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>) <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   Now we can rewrite using the inductive hypothesis. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHls1</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">pf'</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf'</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a>) (<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>:=<a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

        We have made an important bit of progress, as now only a single call to <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> appears in the conclusion, repeated twice.  Trying case analysis on our proofs still will not work, but there is a move we can make to enable it.  Not only does just one call to <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> matter to us now, but it also <i>does not matter what the result of the call is</i>.  In other words, the subgoal should remain true if we replace this <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> call with a fresh variable.  The <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> tactic helps us do exactly that. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <span class="id" title="var">b</span> <span class="id" title="var">hls2</span>) <span class="id" title="var">hls3</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> ((<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf'</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

        The conclusion has gotten markedly simpler.  It seems counterintuitive that we can have an easier time of proving a more general theorem, but such a phenomenon applies to the case here and to many other proofs that use dependent types heavily.  Speaking informally, the reason why this kind of activity helps is that <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations contain some positions where only variables are allowed.  By reducing more elements of a goal to variables, built-in tactics can have more success building <span class="inlinecode"><span class="id" title="keyword">match</span></span> terms under the hood.

<div class="paragraph"> </div>

        In this case, it is helpful to generalize over our two proofs as well. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">pf</span> <span class="id" title="var">pf'</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">pf0</span> : <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">pf'0</span> : (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> ((<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf'0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

        To an experienced dependent types hacker, the appearance of this goal term calls for a celebration.  The formula has a critical property that indicates that our problems are over.  To get our proofs into the right form to apply <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span>, we need to use associativity of list append to rewrite their types.  We could not do so before because other parts of the goal require the proofs to retain their original types.  In particular, the call to <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> that we generalized must have type <span class="inlinecode">(<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a></span>, for some values of the list variables.  If we rewrite the type of the proof used to type-cast this value to something like <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a></span>, then the lefthand side of the equality would no longer match the type of the term we are trying to cast.

<div class="paragraph"> </div>

        However, now that we have generalized over the <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> call, the type of the term being type-cast appears explicitly in the goal and <i>may be rewritten as well</i>.  In particular, the final masterstroke is rewriting everywhere in our goal using associativity of list append. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">app_assoc</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">pf0</span> : <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a> :: <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">pf'0</span> : <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a> = <a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf'0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">pf0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

        We can see that we have achieved the crucial property: the type of each generalized equality proof has syntactically equal operands.  This makes it easy to finish the proof with <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">UIP_refl</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">pf0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">UIP_refl</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">pf'0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="section">fhapp</span></a>.<br/>

<br/>
<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> [<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>].<br/>

<br/>
</div>

<div class="doc">
This proof strategy was cumbersome and unorthodox, from the perspective of mainstream mathematics.  The next section explores an alternative that leads to simpler developments in some cases. 
<div class="paragraph"> </div>

<a name="lab66"></a><h1 class="section">Heterogeneous Equality</h1>

<div class="paragraph"> </div>

 There is another equality predicate, defined in the <span class="inlinecode"><span class="id" title="library">JMeq</span></span> module of the standard library, implementing <i>heterogeneous equality</i>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="inductive">JMeq</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="library">JMeq</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>, <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">JMeq_refl</span> : <span class="id" title="library">JMeq</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The identifier <span class="inlinecode"><span class="id" title="library">JMeq</span></span> stands for "John Major equality," a name coined by Conor McBride as an inside joke about British politics.  The definition <span class="inlinecode"><span class="id" title="library">JMeq</span></span> starts out looking a lot like the definition of <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span>.  The crucial difference is that we may use <span class="inlinecode"><span class="id" title="library">JMeq</span></span> <i>on arguments of different types</i>.  For instance, a lemma that we failed to establish before is trivial with <span class="inlinecode"><span class="id" title="library">JMeq</span></span>.  It makes for prettier theorem statements to define some syntactic shorthand first. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Infix</span> <a name="bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">&quot;</span></a>==" := <span class="id" title="inductive">JMeq</span> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="UIP_refl'"><span class="id" title="definition">UIP_refl'</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>) : <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <span class="id" title="constructor">eq_refl</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <span class="id" title="constructor">eq_refl</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">JMeq_refl</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
There is no quick way to write such a proof by tactics, but the underlying proof term that we want is trivial.

<div class="paragraph"> </div>

   Suppose that we want to use <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#UIP_refl'"><span class="id" title="definition">UIP_refl'</span></a></span> to establish another lemma of the kind we have run into several times so far. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="lemma4"><span class="id" title="lemma">lemma4</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>),<br/>
&nbsp;&nbsp;<span class="id" title="constructor">O</span> <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">eq_refl</span> ⇒ <span class="id" title="constructor">O</span> <span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.Equality.html#UIP_refl'"><span class="id" title="definition">UIP_refl'</span></a> <span class="id" title="var">pf</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
All in all, refreshingly straightforward, but there really is no such thing as a free lunch.  The use of <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> is implemented in terms of an axiom: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="axiom">JMeq_eq</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> == <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

    It may be surprising that we cannot prove that heterogeneous equality implies normal equality.  The difficulties are the same kind we have seen so far, based on limitations of <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations.  The <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span> axiom has been proved on paper to be consistent, but asserting it may still be considered to complicate the logic we work in, so there is some motivation for avoiding it.

<div class="paragraph"> </div>

   We can redo our <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span> associativity proof based around <span class="inlinecode"><span class="id" title="library">JMeq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="fhapp'"><span class="id" title="section">fhapp'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp'.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp'.B"><span class="id" title="variable">B</span></a> : <a class="idref" href="Cpdt.Equality.html#fhapp'.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
This time, the naive theorem statement type-checks. 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fhapp_assoc'"><span class="id" title="lemma">fhapp_assoc'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls3</span> (<span class="id" title="var">hls1</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp'.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a>) (<span class="id" title="var">hls2</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp'.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hls3</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp'.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>) <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
Even better, <span class="inlinecode"><span class="id" title="var">crush</span></span> discharges the first subgoal automatically.  The second subgoal is:
       <br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)) == (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

       It looks like one rewrite with the inductive hypothesis should be enough to make the goal trivial.  Here is what happens when we try that in Coq 8.2:
       <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHls1</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: Impossible to unify "fhlist B ((ls1 ++ ?1572) ++ ?1573)" with
 "fhlist B (ls1 ++ ?1572 ++ ?1573)"
</pre>

<div class="paragraph"> </div>

       Coq 8.4 currently gives an error message about an uncaught exception.  Perhaps that will be fixed soon.  In any case, it is educational to consider a more explicit approach.

<div class="paragraph"> </div>

       We see that <span class="inlinecode"><span class="id" title="library">JMeq</span></span> is not a silver bullet.  We can use it to simplify the statements of equality facts, but the Coq type-checker uses non-trivial heterogeneous equality facts no more readily than it uses standard equality facts.  Here, the problem is that the form <span class="inlinecode">(<a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)</span> is syntactic sugar for an explicit application of a constructor of an inductive type.  That application mentions the type of each tuple element explicitly, and our <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> tries to change one of those elements without updating the corresponding type argument.

<div class="paragraph"> </div>

       We can get around this problem by another multiple use of <span class="inlinecode"><span class="id" title="tactic">generalize</span></span>.  We want to bring into the goal the proper instance of the inductive hypothesis, and we also want to generalize the two relevant uses of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <span class="id" title="var">b</span> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <span class="id" title="var">hls2</span> <span class="id" title="var">hls3</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <span class="id" title="var">b</span> <span class="id" title="var">hls2</span>) <span class="id" title="var">hls3</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">IHls1</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">hls2</span> <span class="id" title="var">hls3</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f0</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> ((<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a>) ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>)), <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> == <span class="id" title="var">f0</span> → (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a>) == (<span class="id" title="var">a0</span>, <span class="id" title="var">f0</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

        Now we can rewrite with append associativity, as before. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">app_assoc</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <span class="id" title="var">f0</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls1"><span class="id" title="variable">ls1</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#ls2"><span class="id" title="variable">ls2</span></a> ++ <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>), <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> == <span class="id" title="var">f0</span> → (<span class="id" title="var">a0</span>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a>) == (<span class="id" title="var">a0</span>, <span class="id" title="var">f0</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

       From this point, the goal is trivial. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">f0</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Equality.html#fhapp'"><span class="id" title="section">fhapp'</span></a>.<br/>

<br/>
</div>

<div class="doc">
This example illustrates a general pattern: heterogeneous equality often simplifies theorem statements, but we still need to do some work to line up some dependent pattern matches that tactics will generate for us.

<div class="paragraph"> </div>

   The proof we have found relies on the <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span> axiom, which we can verify with a command that we will discuss more in two chapters. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <a class="idref" href="Cpdt.Equality.html#fhapp_assoc'"><span class="id" title="lemma">fhapp_assoc'</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Axioms</span>:<br/>
<span class="id" title="axiom">JMeq_eq</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> == <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

It was the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a></span> tactic that implicitly appealed to the axiom.  By restructuring the proof, we can avoid axiom dependence.  A general lemma about pairs provides the key element.  (Our use of <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> above can be thought of as reducing the proof to another, more complex and specialized lemma.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="pair_cong"><span class="id" title="lemma">pair_cong</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A1</span> <span class="id" title="var">A2</span> <span class="id" title="var">B1</span> <span class="id" title="var">B2</span> (<span class="id" title="var">x1</span> : <a class="idref" href="Cpdt.Equality.html#A1"><span class="id" title="variable">A1</span></a>) (<span class="id" title="var">x2</span> : <a class="idref" href="Cpdt.Equality.html#A2"><span class="id" title="variable">A2</span></a>) (<span class="id" title="var">y1</span> : <a class="idref" href="Cpdt.Equality.html#B1"><span class="id" title="variable">B1</span></a>) (<span class="id" title="var">y2</span> : <a class="idref" href="Cpdt.Equality.html#B2"><span class="id" title="variable">B2</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <a class="idref" href="Cpdt.Equality.html#x2"><span class="id" title="variable">x2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#y1"><span class="id" title="variable">y1</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <a class="idref" href="Cpdt.Equality.html#y2"><span class="id" title="variable">y2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Equality.html#x1"><span class="id" title="variable">x1</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Equality.html#y1"><span class="id" title="variable">y1</span></a><span class="id" title="notation">)</span> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.Equality.html#x2"><span class="id" title="variable">x2</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Equality.html#y2"><span class="id" title="variable">y2</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> <span class="id" title="var">y2</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">Hx</span> <span class="id" title="var">Hy</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hy</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">pair_cong</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="fhapp''"><span class="id" title="section">fhapp''</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp''.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="fhapp''.B"><span class="id" title="variable">B</span></a> : <a class="idref" href="Cpdt.Equality.html#fhapp''.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="fhapp_assoc''"><span class="id" title="lemma">fhapp_assoc''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls3</span> (<span class="id" title="var">hls1</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp''.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls1"><span class="id" title="variable">ls1</span></a>) (<span class="id" title="var">hls2</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp''.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls2"><span class="id" title="variable">ls2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hls3</span> : <a class="idref" href="Cpdt.Equality.html#fhlist"><span class="id" title="definition">fhlist</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp''.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.Equality.html#ls3"><span class="id" title="variable">ls3</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a> <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>) <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> (<a class="idref" href="Cpdt.Equality.html#fhapp"><span class="id" title="definition">fhapp</span></a> <a class="idref" href="Cpdt.Equality.html#hls1"><span class="id" title="variable">hls1</span></a> <a class="idref" href="Cpdt.Equality.html#hls2"><span class="id" title="variable">hls2</span></a>) <a class="idref" href="Cpdt.Equality.html#hls3"><span class="id" title="variable">hls3</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.Equality.html#fhapp''"><span class="id" title="section">fhapp''</span></a>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <a class="idref" href="Cpdt.Equality.html#fhapp_assoc''"><span class="id" title="lemma">fhapp_assoc''</span></a>.<br/>
</div>

<div class="doc">
<pre>
Closed under the global context
</pre>

<div class="paragraph"> </div>

One might wonder exactly which elements of a proof involving <span class="inlinecode"><span class="id" title="library">JMeq</span></span> imply that <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span> must be used.  For instance, above we noticed that <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> had brought <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span> into the proof of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp_assoc'"><span class="id" title="lemma">fhapp_assoc'</span></a></span>, yet here we have also used <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> with <span class="inlinecode"><span class="id" title="library">JMeq</span></span> hypotheses while avoiding axioms!  One illuminating exercise is comparing the types of the lemmas that <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> uses under the hood to implement the rewrites.  Here is the normal lemma for <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> rewriting: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="definition">eq_ind_r</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="definition">eq_ind_r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> = <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The corresponding lemma used for <span class="inlinecode"><span class="id" title="library">JMeq</span></span> in the proof of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#pair_cong"><span class="id" title="lemma">pair_cong</span></a></span> is defined internally by <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> as needed, but its type happens to be the following. 
<div class="paragraph"> </div>

 <br/>
<span class="inlinecode"><span class="id" title="var">internal_JMeq_rew_r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> : <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">B0</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">B0</span> → <span class="id" title="keyword">Type</span>), <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> → <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> == <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The key difference is that, where the <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#eq"><span class="id" title="inductive">eq</span></a></span> lemma is parameterized on a predicate of type <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, the <span class="inlinecode"><span class="id" title="library">JMeq</span></span> lemma is parameterized on a predicate of type more like <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  To apply <span class="inlinecode"><span class="id" title="definition">eq_ind_r</span></span> with a proof of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>, it is only necessary to rearrange the goal into an application of a <span class="inlinecode"><span class="id" title="keyword">fun</span></span> abstraction to <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>.  In contrast, to apply the alternative principle, it is necessary to rearrange the goal to an application of a <span class="inlinecode"><span class="id" title="keyword">fun</span></span> abstraction to both <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> and <i>its type</i>.  In other words, the predicate must be <i>polymorphic</i> in <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>'s type; any type must make sense, from a type-checking standpoint.  There may be cases where the former rearrangement is easy to do in a type-correct way, but the second rearrangement done naively leads to a type error.

<div class="paragraph"> </div>

When <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> cannot figure out how to apply the alternative principle for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">==</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> where <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> have the same type, the tactic can instead use a different theorem, which is easy to prove as a composition of <span class="inlinecode"><span class="id" title="definition">eq_ind_r</span></span> and <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="lemma">JMeq_ind_r</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="lemma">JMeq_ind_r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> == <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Ironically, where in the proof of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp_assoc'"><span class="id" title="lemma">fhapp_assoc'</span></a></span> we used <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="lemma">app_assoc</span></span> to make it clear that a use of <span class="inlinecode"><span class="id" title="library">JMeq</span></span> was actually homogeneously typed, we created a situation where <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> applied the axiom-based <span class="inlinecode"><span class="id" title="lemma">JMeq_ind_r</span></span> instead of the axiom-free principle!

<div class="paragraph"> </div>

For another simple example, consider this theorem that applies a heterogeneous equality to prove a congruence fact. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="out_of_luck"><span class="id" title="lemma">out_of_luck</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="inductive">nat</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <a class="idref" href="Cpdt.Equality.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.Equality.html#bec439b36d449155cf4821d64d620d15"><span class="id" title="notation">==</span></a> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.Equality.html#m"><span class="id" title="variable">m</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Applying <span class="inlinecode"><span class="id" title="lemma">JMeq_ind_r</span></span> is easy, as the <span class="inlinecode"><span class="id" title="tactic">pattern</span></span> tactic will transform the goal into an application of an appropriate <span class="inlinecode"><span class="id" title="keyword">fun</span></span> to a term that we want to abstract.  (In general, <span class="inlinecode"><span class="id" title="tactic">pattern</span></span> abstracts over a term by introducing a new anonymous function taking that term as argument.) 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pattern</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> == <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒ <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> == <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="lemma">JMeq_ind_r</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> := <span class="id" title="var">m</span>); <span class="id" title="tactic">auto</span>.<br/>

<br/>
</div>

<div class="doc">
However, we run into trouble trying to get the goal into a form compatible with the alternative principle. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span> 2.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="tactic">pattern</span> <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>.
<div class="paragraph"> </div>

</span><pre>
Error: The abstracted term "fun (P : Set) (n0 : P) =&gt; S n0 == S m"
is not well typed.
Illegal application (Type Error): 
The term "S" of type "nat -&gt; nat"
cannot be applied to the term
 "n0" : "P"
This term has type "P" which should be coercible to 
"nat".
</pre>

<div class="paragraph"> </div>

In other words, the successor function <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> is insufficiently polymorphic.  If we try to generalize over the type of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>, we find that <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> is no longer legal to apply to <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Why did we not run into this problem in our proof of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhapp_assoc''"><span class="id" title="lemma">fhapp_assoc''</span></a></span>?  The reason is that the pair constructor is polymorphic in the types of the pair components, while functions like <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> are not polymorphic at all.  Use of such non-polymorphic functions with <span class="inlinecode"><span class="id" title="library">JMeq</span></span> tends to push toward use of axioms.  The example with <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> here is a bit unrealistic; more likely cases would involve functions that have <i>some</i> polymorphism, but not enough to allow abstractions of the sort we attempted above with <span class="inlinecode"><span class="id" title="tactic">pattern</span></span>.  For instance, we might have an equality between two lists, where the goal only type-checks when the terms involved really are lists, though everything is polymorphic in the types of list data elements.  The <a href="http://www.mpi-sws.org/~gil/Heq/">Heq</a> library builds up a slightly different foundation to help avoid such problems. 
<div class="paragraph"> </div>

<a name="lab67"></a><h1 class="section">Equivalence of Equality Axioms</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Assuming axioms (like axiom K and <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span>) is a hazardous business.  The due diligence associated with it is necessarily global in scope, since two axioms may be consistent alone but inconsistent together.  It turns out that all of the major axioms proposed for reasoning about equality in Coq are logically equivalent, so that we only need to pick one to assert without proof.  In this section, we demonstrate by showing how each of the previous two sections' approaches reduces to the other logically.

<div class="paragraph"> </div>

   To show that <span class="inlinecode"><span class="id" title="library">JMeq</span></span> and its axiom let us prove <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span>, we start from the lemma <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#UIP_refl'"><span class="id" title="definition">UIP_refl'</span></a></span> from the previous section.  The rest of the proof is trivial. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="UIP_refl''"><span class="id" title="lemma">UIP_refl''</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>), <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="notation">=</span> <span class="id" title="constructor">eq_refl</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> (<a class="idref" href="Cpdt.Equality.html#UIP_refl'"><span class="id" title="definition">UIP_refl'</span></a> <span class="id" title="var">pf</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The other direction is perhaps more interesting.  Assume that we only have the axiom of the <span class="inlinecode"><span class="id" title="library">Eqdep</span></span> module available.  We can define <span class="inlinecode"><span class="id" title="library">JMeq</span></span> in a way that satisfies the same interface as the combination of the <span class="inlinecode"><span class="id" title="library">JMeq</span></span> module's inductive definition and axiom. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="JMeq'"><span class="id" title="definition">JMeq'</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">y</span> : <a class="idref" href="Cpdt.Equality.html#B"><span class="id" title="variable">B</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="notation">∃</span> <span class="id" title="var">pf</span> : <a class="idref" href="Cpdt.Equality.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">eq_refl</span> ⇒ <a class="idref" href="Cpdt.Equality.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Infix</span> <a name="39064cd091a0ac785497a0862b96127b"><span class="id" title="notation">&quot;</span></a>===" := <a class="idref" href="Cpdt.Equality.html#JMeq'"><span class="id" title="definition">JMeq'</span></a> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>

<br/>
</div>

<div class="doc">
We say that, by definition, <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> are equal if and only if there exists a proof <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> that their types are equal, such that <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> equals the result of casting <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> with <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span>.  This statement can look strange from the standpoint of classical math, where we almost never mention proofs explicitly with quantifiers in formulas, but it is perfectly legal Coq code.

<div class="paragraph"> </div>

   We can easily prove a theorem with the same type as that of the <span class="inlinecode"><span class="id" title="constructor">JMeq_refl</span></span> constructor of <span class="inlinecode"><span class="id" title="library">JMeq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="JMeq_refl'"><span class="id" title="lemma">JMeq_refl'</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Equality.html#39064cd091a0ac785497a0862b96127b"><span class="id" title="notation">===</span></a> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.Equality.html#JMeq'"><span class="id" title="definition">JMeq'</span></a>; <span class="id" title="tactic">exists</span> (<span class="id" title="constructor">eq_refl</span> <span class="id" title="var">A</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
The proof of an analogue to <span class="inlinecode"><span class="id" title="axiom">JMeq_eq</span></span> is a little more interesting, but most of the action is in appealing to <span class="inlinecode"><span class="id" title="lemma">UIP_refl</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="JMeq_eq'"><span class="id" title="lemma">JMeq_eq'</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Cpdt.Equality.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.Equality.html#39064cd091a0ac785497a0862b96127b"><span class="id" title="notation">===</span></a> <a class="idref" href="Cpdt.Equality.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.Equality.html#y"><span class="id" title="variable">y</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.Equality.html#JMeq'"><span class="id" title="definition">JMeq'</span></a>; <span class="id" title="tactic">intros</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <span class="id" title="tactic">exists</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> = <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a>) <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>      
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">x0</span> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> = <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.GeneralRec.html#thunk_eq_coind.H"><span class="id" title="variable">H</span></a> : <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <span class="id" title="keyword">match</span> <span class="id" title="var">x0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a>) <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>      
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">x0</span> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> = <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x0</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">_</span> = <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a>) <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Predicates.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a> ⇒ <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> = <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a>
<div class="paragraph"> </div>

</span>      
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">UIP_refl</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x0</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We see that, in a very formal sense, we are free to switch back and forth between the two styles of proofs about equality proofs.  One style may be more convenient than the other for some proofs, but we can always interconvert between our results.  The style that does not use heterogeneous equality may be preferable in cases where many results do not require the tricks of this chapter, since then the use of axioms is avoided altogether for the simple cases, and a wider audience will be able to follow those "simple" proofs.  On the other hand, heterogeneous equality often makes for shorter and more readable theorem statements. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab68"></a><h1 class="section">Equality of Functions</h1>

<div class="paragraph"> </div>

 The following seems like a reasonable theorem to want to hold, and it does hold in set theory.
   <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a class="idref" href="Cpdt.Equality.html#two_funs"><span class="id" title="lemma">two_funs</span></a> : (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) = (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + 0).<br/>
&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>   Unfortunately, this theorem is not provable in CIC without additional axioms.  None of the definitional equality rules force function equality to be <i>extensional</i>.  That is, the fact that two functions return equal results on equal inputs does not imply that the functions are equal.  We <i>can</i> assert function extensionality as an axiom, and indeed the standard library already contains that axiom. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">FunctionalExtensionality</span>.<br/>
<span class="id" title="keyword">About</span> <span class="id" title="lemma">functional_extensionality</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="lemma">functional_extensionality</span> :<br/>
<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a>), (<span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> = <a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a>) → <a class="idref" href="Cpdt.Large.html#Int.f"><span class="id" title="definition">f</span></a> = <a class="idref" href="Cpdt.Match.html#t7.g"><span class="id" title="variable">g</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 This axiom has been verified metatheoretically to be consistent with CIC and the two equality axioms we considered previously.  With it, the proof of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#two_funs"><span class="id" title="lemma">two_funs</span></a></span> is trivial. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="two_funs"><span class="id" title="lemma">two_funs</span></a> : <span class="id" title="notation">(</span><span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.Equality.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> 0<span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="lemma">functional_extensionality</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The same axiom can help us prove equality of types, where we need to "reason under quantifiers." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="forall_eq"><span class="id" title="lemma">forall_eq</span></a> : <span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="notation">=</span> <span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">_</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="inductive">True</span><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">
There are no immediate opportunities to apply <span class="inlinecode"><span class="id" title="lemma">functional_extensionality</span></span>, but we can use <span class="inlinecode"><span class="id" title="tactic">change</span></span> to fix that problem. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="notation">(</span><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span>, (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">True</span><span class="id" title="notation">)</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">functional_extensionality</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Equality.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">True</span>)).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">2 <span class="id" title="keyword">subgoals</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <span class="id" title="inductive">True</span>) = (<a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <span class="id" title="inductive">True</span>)<br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 <span class="id" title="var">is</span>:<br/>
&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> = <span class="id" title="inductive">True</span>
<div class="paragraph"> </div>

</span>      
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Unlike in the case of <span class="inlinecode"><span class="id" title="axiom">eq_rect_eq</span></span>, we have no way of deriving this axiom of <i>functional extensionality</i> for types with decidable equality.  To allow equality reasoning without axioms, it may be worth rewriting a development to replace functions with alternate representations, such as finite map types for which extensionality is derivable in CIC. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>