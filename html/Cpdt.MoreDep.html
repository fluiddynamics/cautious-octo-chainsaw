<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.MoreDep</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.MoreDep</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 Subset types and their relatives help us integrate verification with programming.  Though they reorganize the certified programmer's workflow, they tend not to have deep effects on proofs.  We write largely the same proofs as we would for classical verification, with some of the structure moved into the programs themselves.  It turns out that, when we use dependent types to their full potential, we warp the development and proving process even more than that, picking up "free theorems" to the extent that often a certified program is hardly more complex than its uncertified counterpart in Haskell or ML.

<div class="paragraph"> </div>

   In particular, we have only scratched the tip of the iceberg that is Coq's inductive definition mechanism.  The inductive types we have seen so far have their counterparts in the other proof assistants that we surveyed in Chapter 1.  This chapter explores the strange new world of dependent inductive datatypes outside <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a possibility that sets Coq apart from all of the competition not based on type theory. 
<div class="paragraph"> </div>

<a name="lab51"></a><h1 class="section">Length-Indexed Lists</h1>

<div class="paragraph"> </div>

 Many introductions to dependent types start out by showing how to use them to eliminate array bounds checks.  When the type of an array tells you how many elements it has, your compiler can detect out-of-bounds dereferences statically.  Since we are working in a pure functional language, the next best thing is length-indexed lists, which the following code defines. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="ilist"><span class="id" title="section">ilist</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="ilist.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Set</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="ilist"><span class="id" title="inductive">ilist</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <a name="Nil"><span class="id" title="constructor">Nil</span></a> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <span class="id" title="constructor">O</span><br/>
&nbsp;&nbsp;| <a name="Cons"><span class="id" title="constructor">Cons</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.MoreDep.html#ilist.A"><span class="id" title="variable">A</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
</div>

<div class="doc">
We see that, within its section, <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span> is given type <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.  Previously, every inductive type we have seen has either had plain <span class="inlinecode"><span class="id" title="keyword">Set</span></span> as its type or has been a predicate with some type ending in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  The full generality of inductive definitions lets us integrate the expressivity of predicates directly into our normal programming.

<div class="paragraph"> </div>

   The <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> argument to <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span> tells us the length of the list.  The types of <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span>'s constructors tell us that a <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Nil"><span class="id" title="constructor">Nil</span></a></span> list has length <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#O"><span class="id" title="constructor">O</span></a></span> and that a <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a></span> list has length one greater than the length of its tail.  We may apply <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span> to any natural number, even natural numbers that are only known at runtime.  It is this breaking of the <i>phase distinction</i> that characterizes <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a></span> as <i>dependently typed</i>.

<div class="paragraph"> </div>

   In expositions of list types, we usually see the length function defined first, but here that would not be a very productive function to code.  Instead, let us implement list concatenation. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="app"><span class="id" title="definition">app</span></a> <span class="id" title="var">n1</span> (<span class="id" title="var">ls1</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n1"><span class="id" title="variable">n1</span></a>) <span class="id" title="var">n2</span> (<span class="id" title="var">ls2</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n2"><span class="id" title="variable">n2</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<a class="idref" href="Cpdt.MoreDep.html#n1"><span class="id" title="variable">n1</span></a> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.MoreDep.html#n2"><span class="id" title="variable">n2</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Nil"><span class="id" title="constructor">Nil</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#ls2"><span class="id" title="variable">ls2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">ls1'</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Cpdt.MoreDep.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">ls1'</span> <a class="idref" href="Cpdt.MoreDep.html#ls2"><span class="id" title="variable">ls2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Past Coq versions signalled an error for this definition.  The code is still invalid within Coq's core language, but current Coq versions automatically add annotations to the original program, producing a valid core program.  These are the annotations on <span class="inlinecode"><span class="id" title="keyword">match</span></span> discriminees that we began to study in the previous chapter.  We can rewrite <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#app"><span class="id" title="definition">app</span></a></span> to give the annotations explicitly. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="app'"><span class="id" title="definition">app'</span></a> <span class="id" title="var">n1</span> (<span class="id" title="var">ls1</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n1"><span class="id" title="variable">n1</span></a>) <span class="id" title="var">n2</span> (<span class="id" title="var">ls2</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n2"><span class="id" title="variable">n2</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<a class="idref" href="Cpdt.MoreDep.html#n1"><span class="id" title="variable">n1</span></a> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.MoreDep.html#n2"><span class="id" title="variable">n2</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#ls1"><span class="id" title="variable">ls1</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <span class="id" title="var">n1</span>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<a class="idref" href="Cpdt.MoreDep.html#n1"><span class="id" title="variable">n1</span></a> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.MoreDep.html#n2"><span class="id" title="variable">n2</span></a>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Nil"><span class="id" title="constructor">Nil</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#ls2"><span class="id" title="variable">ls2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">ls1'</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Cpdt.MoreDep.html#app'"><span class="id" title="definition">app'</span></a> <span class="id" title="var">ls1'</span> <a class="idref" href="Cpdt.MoreDep.html#ls2"><span class="id" title="variable">ls2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Using <span class="inlinecode"><span class="id" title="keyword">return</span></span> alone allowed us to express a dependency of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> result type on the <i>value</i> of the discriminee.  What <span class="inlinecode"><span class="id" title="keyword">in</span></span> adds to our arsenal is a way of expressing a dependency on the <i>type</i> of the discriminee.  Specifically, the <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#n1"><span class="id" title="variable">n1</span></a></span> in the <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause above is a <i>binding occurrence</i> whose scope is the <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause.

<div class="paragraph"> </div>

We may use <span class="inlinecode"><span class="id" title="keyword">in</span></span> clauses only to bind names for the arguments of an inductive type family.  That is, each <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause must be an inductive type family name applied to a sequence of underscores and variable names of the proper length.  The positions for <i>parameters</i> to the type family must all be underscores.  Parameters are those arguments declared with section variables or with entries to the left of the first colon in an inductive definition.  They cannot vary depending on which constructor was used to build the discriminee, so Coq prohibits pointless matches on them.  It is those arguments defined in the type to the right of the colon that we may name with <span class="inlinecode"><span class="id" title="keyword">in</span></span> clauses.

<div class="paragraph"> </div>

Our <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#app"><span class="id" title="definition">app</span></a></span> function could be typed in so-called <i>stratified</i> type systems, which avoid true dependency.  That is, we could consider the length indices to lists to live in a separate, compile-time-only universe from the lists themselves.  Compile-time data may be <i>erased</i> such that we can still execute a program.  As an example where erasure would not work, consider an injection function from regular lists to length-indexed lists.  Here the run-time computation actually depends on details of the compile-time argument, if we decide that the list to inject can be considered compile-time.  More commonly, we think of lists as run-time data.  Neither case will work with naive erasure.  (It is not too important to grasp the details of this run-time/compile-time distinction, since Coq's expressive power comes from avoiding such restrictions.) 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="inject"><span class="id" title="definition">inject</span></a> (<span class="id" title="var">ls</span> : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.MoreDep.html#ilist.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Nil"><span class="id" title="constructor">Nil</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> <span class="id" title="notation">::</span> <span class="id" title="var">t</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">h</span> (<a class="idref" href="Cpdt.MoreDep.html#inject"><span class="id" title="definition">inject</span></a> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can define an inverse conversion and prove that it really is an inverse. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="unject"><span class="id" title="definition">unject</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">ls</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.MoreDep.html#ilist.A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Nil"><span class="id" title="constructor">Nil</span></a> ⇒ <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.MoreDep.html#unject"><span class="id" title="definition">unject</span></a> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="inject_inverse"><span class="id" title="lemma">inject_inverse</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ls</span>, <a class="idref" href="Cpdt.MoreDep.html#unject"><span class="id" title="definition">unject</span></a> (<a class="idref" href="Cpdt.MoreDep.html#inject"><span class="id" title="definition">inject</span></a> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a>) <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Now let us attempt a function that is surprisingly tricky to write.  In ML, the list head function raises an exception when passed an empty list.  With length-indexed lists, we can rule out such invalid calls statically, and here is a first attempt at doing so.  We write <span class="inlinecode">???</span> as a placeholder for a term that we do not know how to write, not for any real Coq notation like those introduced two chapters ago.
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> : <a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>)) : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Nil"><span class="id" title="constructor">Nil</span></a> ⇒ ???<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>It is not clear what to write for the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Nil"><span class="id" title="constructor">Nil</span></a></span> case, so we are stuck before we even turn our function over to the type checker.  We could try omitting the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Nil"><span class="id" title="constructor">Nil</span></a></span> case:
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> : <a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>)) : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: Non exhaustive pattern-matching: no clause found for pattern Nil
</pre>

<div class="paragraph"> </div>

Unlike in ML, we cannot use inexhaustive pattern matching, because there is no conception of a <tt>Match</tt> exception to be thrown.  In fact, recent versions of Coq <i>do</i> allow this, by implicit translation to a <span class="inlinecode"><span class="id" title="keyword">match</span></span> that considers all constructors; the error message above was generated by an older Coq version.  It is educational to discover for ourselves the encoding that the most recent Coq versions use.  We might try using an <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause somehow.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> : <a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>)) : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a> (<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.Coinductive.html#h"><span class="id" title="variable">h</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: The reference n was not found in the current environment
</pre>

<div class="paragraph"> </div>

In this and other cases, we feel like we want <span class="inlinecode"><span class="id" title="keyword">in</span></span> clauses with type family arguments that are not variables.  Unfortunately, Coq only supports variables in those positions.  A completely general mechanism could only be supported with a solution to the problem of higher-order unification, which is undecidable.  There <i>are</i> useful heuristics for handling non-variable indices which are gradually making their way into Coq, but we will spend some time in this and the next few chapters on effective pattern matching on dependent types using only the primitive <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations.

<div class="paragraph"> </div>

Our final, working attempt at <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a></span> uses an auxiliary function and a surprising <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="hd'"><span class="id" title="definition">hd'</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">ls</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> <span class="id" title="var">n</span>) <span class="id" title="keyword">return</span> (<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span> <span class="id" title="constructor">O</span> ⇒ <span class="id" title="inductive">unit</span> | <span class="id" title="constructor">S</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#ilist.A"><span class="id" title="variable">A</span></a> <span class="id" title="keyword">end</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Nil"><span class="id" title="constructor">Nil</span></a> ⇒ <span class="id" title="constructor">tt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Cpdt.Equality.html#ilist"><span class="id" title="definition">ilist</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> → <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>  
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="hd"><span class="id" title="definition">hd</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">ls</span> : <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="inductive">ilist</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>)) : <a class="idref" href="Cpdt.MoreDep.html#ilist.A"><span class="id" title="variable">A</span></a> := <a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a> <a class="idref" href="Cpdt.MoreDep.html#ls"><span class="id" title="variable">ls</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#ilist"><span class="id" title="section">ilist</span></a>.<br/>

<br/>
</div>

<div class="doc">
We annotate our main <span class="inlinecode"><span class="id" title="keyword">match</span></span> with a type that is itself a <span class="inlinecode"><span class="id" title="keyword">match</span></span>.  We write that the function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a></span> returns <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span> when the list is empty and returns the carried type <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span> in all other cases.  In the definition of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a></span>, we just call <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a></span>.  Because the index of <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#ls"><span class="id" title="variable">ls</span></a></span> is known to be nonzero, the type checker reduces the <span class="inlinecode"><span class="id" title="keyword">match</span></span> in the type of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd'"><span class="id" title="definition">hd'</span></a></span> to <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab52"></a><h1 class="section">The One Rule of Dependent Pattern Matching in Coq</h1>

<div class="paragraph"> </div>

 The rest of this chapter will demonstrate a few other elegant applications of dependent types in Coq.  Readers encountering such ideas for the first time often feel overwhelmed, concluding that there is some magic at work whereby Coq sometimes solves the halting problem for the programmer and sometimes does not, applying automated program understanding in a way far beyond what is found in conventional languages.  The point of this section is to cut off that sort of thinking right now!  Dependent type-checking in Coq follows just a few algorithmic rules.  Chapters 10 and 12 introduce many of those rules more formally, and the main additional rule is centered on <i>dependent pattern matching</i> of the kind we met in the previous section.

<div class="paragraph"> </div>

A dependent pattern match is a <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression where the type of the overall <span class="inlinecode"><span class="id" title="keyword">match</span></span> is a function of the value and/or the type of the <i>discriminee</i>, the value being matched on.  In other words, the <span class="inlinecode"><span class="id" title="keyword">match</span></span> type <i>depends</i> on the discriminee.

<div class="paragraph"> </div>

When exactly will Coq accept a dependent pattern match as well-typed?  Some other dependently typed languages employ fancy decision procedures to determine when programs satisfy their very expressive types.  The situation in Coq is just the opposite.  Only very straightforward symbolic rules are applied.  Such a design choice has its drawbacks, as it forces programmers to do more work to convince the type checker of program validity.  However, the great advantage of a simple type checking algorithm is that its action on <i>invalid</i> programs is easier to understand!

<div class="paragraph"> </div>

We come now to the one rule of dependent pattern matching in Coq.  A general dependent pattern match assumes this form (with unnecessary parentheses included to make the syntax easier to parse):
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a> <span class="id" title="keyword">as</span> <a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a> <a class="idref" href="Cpdt.GeneralRec.html#x1"><span class="id" title="variable">x1</span></a> ... <span class="id" title="var">xn</span>) <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a> <span class="id" title="var">z1</span> ... <span class="id" title="var">zm</span> ⇒ <a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ...<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The discriminee is a term <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span>, a value in some inductive type family <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span>, which takes <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> arguments.  An <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause binds the name <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> to refer to the discriminee <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span>.  An <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause binds an explicit name <span class="inlinecode"><span class="id" title="var">xi</span></span> for the <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a></span>th argument passed to <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> in the type of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span>.

<div class="paragraph"> </div>

We bind these new variables <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> and <span class="inlinecode"><span class="id" title="var">xi</span></span> so that they may be referred to in <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a></span>, a type given in the <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause.  The overall type of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> will be <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a></span>, with <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> substituted for <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span>, and with each <span class="inlinecode"><span class="id" title="var">xi</span></span> substituted by the actual argument appearing in that position within <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span>'s type.

<div class="paragraph"> </div>

In general, each case of a <span class="inlinecode"><span class="id" title="keyword">match</span></span> may have a pattern built up in several layers from the constructors of various inductive type families.  To keep this exposition simple, we will focus on patterns that are just single applications of inductive type constructors to lists of variables.  Coq actually compiles the more general kind of pattern matching into this more restricted kind automatically, so understanding the typing of <span class="inlinecode"><span class="id" title="keyword">match</span></span> requires understanding the typing of <span class="inlinecode"><span class="id" title="keyword">match</span></span>es lowered to match one constructor at a time.

<div class="paragraph"> </div>

The last piece of the typing rule tells how to type-check a <span class="inlinecode"><span class="id" title="keyword">match</span></span> case.  A generic constructor application <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><span class="id" title="var">z1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">zm</span></span> has some type <span class="inlinecode"><a class="idref" href="Cpdt.Generic.html#ok.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode"><span class="id" title="var">x1'</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn'</span></span>, an application of the type family used in <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span>'s type, probably with occurrences of the <span class="inlinecode"><span class="id" title="var">zi</span></span> variables.  From here, a simple recipe determines what type we will require for the case body <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a></span>.  The type of <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t7.B"><span class="id" title="variable">B</span></a></span> should be <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#U"><span class="id" title="variable">U</span></a></span> with the following two substitutions applied: we replace <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#y"><span class="id" title="variable">y</span></a></span> (the <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause variable) with <span class="inlinecode"><a class="idref" href="Cpdt.Equality.html#fhlist_map.C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><span class="id" title="var">z1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">zm</span></span>, and we replace each <span class="inlinecode"><span class="id" title="var">xi</span></span> (the <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause variables) with <span class="inlinecode"><span class="id" title="var">xi'</span></span>.  In other words, we specialize the result type based on what we learn based on which pattern has matched the discriminee.

<div class="paragraph"> </div>

This is an exhaustive description of the ways to specify how to take advantage of which pattern has matched!  No other mechanisms come into play.  For instance, there is no way to specify that the types of certain free variables should be refined based on which pattern has matched.  In the rest of the book, we will learn design patterns for achieving similar effects, where each technique leads to an encoding only in terms of <span class="inlinecode"><span class="id" title="keyword">in</span></span>, <span class="inlinecode"><span class="id" title="keyword">as</span></span>, and <span class="inlinecode"><span class="id" title="keyword">return</span></span> clauses.

<div class="paragraph"> </div>

A few details have been omitted above.  In Chapter 3, we learned that inductive type families may have both <i>parameters</i> and regular arguments.  Within an <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause, a parameter position must have the wildcard <span class="inlinecode"><span class="id" title="var">_</span></span> written, instead of a variable.  (In general, Coq uses wildcard <span class="inlinecode"><span class="id" title="var">_</span></span>'s either to indicate pattern variables that will not be mentioned again or to indicate positions where we would like type inference to infer the appropriate terms.)  Furthermore, recent Coq versions are adding more and more heuristics to infer dependent <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations in certain conditions.  The general annotation inference problem is undecidable, so there will always be serious limitations on how much work these heuristics can do.  When in doubt about why a particular dependent <span class="inlinecode"><span class="id" title="keyword">match</span></span> is failing to type-check, add an explicit <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation!  At that point, the mechanical rule sketched in this section will provide a complete account of "what the type checker is thinking."  Be sure to avoid the common pitfall of writing a <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation that does not mention any variables bound by <span class="inlinecode"><span class="id" title="keyword">in</span></span> or <span class="inlinecode"><span class="id" title="keyword">as</span></span>; such a <span class="inlinecode"><span class="id" title="keyword">match</span></span> will never refine typing requirements based on which pattern has matched.  (One simple exception to this rule is that, when the discriminee is a variable, that same variable may be treated as if it were repeated as an <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause.) 
<div class="paragraph"> </div>

<a name="lab53"></a><h1 class="section">A Tagless Interpreter</h1>

<div class="paragraph"> </div>

 A favorite example for motivating the power of functional programming is implementation of a simple expression language interpreter.  In ML and Haskell, such interpreters are often implemented using an algebraic datatype of values, where at many points it is checked that a value was built with the right constructor of the value type.  With dependent types, we can implement a <i>tagless</i> interpreter that both removes this source of runtime inefficiency and gives us more confidence that our implementation is correct. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="type"><span class="id" title="inductive">type</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
| <a name="Nat"><span class="id" title="constructor">Nat</span></a> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a><br/>
| <a name="Bool"><span class="id" title="constructor">Bool</span></a> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a><br/>
| <a name="Prod"><span class="id" title="constructor">Prod</span></a> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="exp"><span class="id" title="inductive">exp</span></a> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="NConst"><span class="id" title="constructor">NConst</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
| <a name="Plus"><span class="id" title="constructor">Plus</span></a> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
| <a name="Eq"><span class="id" title="constructor">Eq</span></a> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a><br/>
<br/>
| <a name="BConst"><span class="id" title="constructor">BConst</span></a> : <span class="id" title="inductive">bool</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a><br/>
| <a name="And"><span class="id" title="constructor">And</span></a> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a><br/>
| <a name="If"><span class="id" title="constructor">If</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><br/>
<br/>
| <a name="Pair"><span class="id" title="constructor">Pair</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>, <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <a class="idref" href="Cpdt.MoreDep.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a>)<br/>
| <a name="Fst"><span class="id" title="constructor">Fst</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>, <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <a class="idref" href="Cpdt.MoreDep.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t1"><span class="id" title="variable">t1</span></a><br/>
| <a name="Snd"><span class="id" title="constructor">Snd</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>, <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <a class="idref" href="Cpdt.MoreDep.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a>) <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a>.<br/>

<br/>
</div>

<div class="doc">
We have a standard algebraic datatype <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span>, defining a type language of naturals, Booleans, and product (pair) types.  Then we have the indexed inductive type <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span>, where the argument to <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span> tells us the encoded type of an expression.  In effect, we are defining the typing rules for expressions simultaneously with the syntax.

<div class="paragraph"> </div>

   We can give types and expressions semantics in a new style, based critically on the chance for <i>type-level computation</i>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="typeDenote"><span class="id" title="definition">typeDenote</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> ⇒ <span class="id" title="inductive">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <span class="id" title="var">t1</span> <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>%<span class="id" title="var">type</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> function compiles types of our object language into "native" Coq types.  It is deceptively easy to implement.  The only new thing we see is the <span class="inlinecode">%</span><tt>type</tt> annotation, which tells Coq to parse the <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression using the notations associated with types.  Without this annotation, the <span class="inlinecode">×</span> would be interpreted as multiplication on naturals, rather than as the product type constructor.  The token <tt>type</tt> is one example of an identifier bound to a <i>notation scope delimiter</i>.  In this book, we will not go into more detail on notation scopes, but the Coq manual can be consulted for more information.

<div class="paragraph"> </div>

   We can define a function <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a></span> that is typed in terms of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">+</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Eq"><span class="id" title="constructor">Eq</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="abbreviation">eq_nat_dec</span> (<a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span>) <span class="id" title="keyword">then</span> <span class="id" title="constructor">true</span> <span class="id" title="keyword">else</span> <span class="id" title="constructor">false</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#And"><span class="id" title="constructor">And</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">&amp;&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#If"><span class="id" title="constructor">If</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e'</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e'</span> <span class="id" title="keyword">then</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">else</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Fst"><span class="id" title="constructor">Fst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e'</span> ⇒ <span class="id" title="definition">fst</span> (<a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Snd"><span class="id" title="constructor">Snd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e'</span> ⇒ <span class="id" title="definition">snd</span> (<a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Despite the fancy type, the function definition is routine.  In fact, it is less complicated than what we would write in ML or Haskell 98, since we do not need to worry about pushing final values in and out of an algebraic datatype.  The only unusual thing is the use of an expression of the form <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a></span> in the <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Eq"><span class="id" title="constructor">Eq</span></a></span> case.  Remember that <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#eq_nat_dec"><span class="id" title="definition">eq_nat_dec</span></a></span> has a rich dependent type, rather than a simple Boolean type.  Coq's native <span class="inlinecode"><span class="id" title="keyword">if</span></span> is overloaded to work on a test of any two-constructor type, so we can use <span class="inlinecode"><span class="id" title="keyword">if</span></span> to build a simple Boolean from the <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span> that <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#eq_nat_dec"><span class="id" title="definition">eq_nat_dec</span></a></span> returns.

<div class="paragraph"> </div>

   We can implement our old favorite, a constant folding function, and prove it correct.  It will be useful to write a function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a></span> that checks if an <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span> of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a></span> type is a pair, returning its two components if so.  Unsurprisingly, a first attempt leads to a type error.
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a> (<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>)) : <span class="id" title="inductive">option</span> (<a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> × <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>)) <span class="id" title="keyword">return</span> <span class="id" title="inductive">option</span> (<a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> × <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ⇒ <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>, <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: The reference t2 was not found in the current environment
</pre>

<div class="paragraph"> </div>

We run again into the problem of not being able to specify non-variable arguments in <span class="inlinecode"><span class="id" title="keyword">in</span></span> clauses.  The problem would just be hopeless without a use of an <span class="inlinecode"><span class="id" title="keyword">in</span></span> clause, though, since the result type of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> depends on an argument to <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span>.  Our solution will be to use a more general type, as we did for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a></span>.  First, we define a type-valued function to use in assigning a type to <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="pairOutType"><span class="id" title="definition">pairOutType</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#type"><span class="id" title="inductive">type</span></a>) := <span class="id" title="inductive">option</span> (<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Prod"><span class="id" title="constructor">Prod</span></a> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="var">t1</span> <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="inductive">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
When passed a type that is a product, <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOutType"><span class="id" title="definition">pairOutType</span></a></span> returns our final desired type.  On any other input type, <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOutType"><span class="id" title="definition">pairOutType</span></a></span> returns the harmless <span class="inlinecode"><span class="id" title="inductive">option</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span>, since we do not care about extracting components of non-pairs.  Now <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a></span> is easy to write. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="pairOut"><span class="id" title="definition">pairOut</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="var">t</span>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.MoreDep.html#pairOutType"><span class="id" title="definition">pairOutType</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <span class="id" title="constructor">Some</span> <span class="id" title="notation">(</span><span class="id" title="var">e1</span><span class="id" title="notation">,</span> <span class="id" title="var">e2</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
With <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a></span> available, we can write <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a></span> in a straightforward way.  There are really no surprises beyond that Coq verifies that this code has such an expressive type, given the small annotation burden.  In some places, we see that Coq's <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotation inference is too smart for its own good, and we have to turn that inference off with explicit <span class="inlinecode"><span class="id" title="keyword">return</span></span> clauses. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e1'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e2'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a>, <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n1</span>, <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> (<span class="id" title="var">n1</span> <span class="id" title="notation">+</span> <span class="id" title="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Plus"><span class="id" title="constructor">Plus</span></a> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Eq"><span class="id" title="constructor">Eq</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e1'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e2'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a>, <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n1</span>, <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">n2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> (<span class="id" title="keyword">if</span> <span class="id" title="abbreviation">eq_nat_dec</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> <span class="id" title="keyword">then</span> <span class="id" title="constructor">true</span> <span class="id" title="keyword">else</span> <span class="id" title="constructor">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Eq"><span class="id" title="constructor">Eq</span></a> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#And"><span class="id" title="constructor">And</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e1'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e2'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a>, <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">b1</span>, <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">b2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> (<span class="id" title="var">b1</span> <span class="id" title="notation">&amp;&amp;</span> <span class="id" title="var">b2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#And"><span class="id" title="constructor">And</span></a> <a class="idref" href="Cpdt.MoreDep.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Cpdt.MoreDep.html#e2'"><span class="id" title="variable">e2'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#If"><span class="id" title="constructor">If</span></a> <span class="id" title="var">_</span> <span class="id" title="var">e</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="constructor">true</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="constructor">false</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#If"><span class="id" title="constructor">If</span></a> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Fst"><span class="id" title="constructor">Fst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">p</span> ⇒ <span class="id" title="definition">fst</span> <span class="id" title="var">p</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Fst"><span class="id" title="constructor">Fst</span></a> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Snd"><span class="id" title="constructor">Snd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e'</span> := <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">p</span> ⇒ <span class="id" title="definition">snd</span> <span class="id" title="var">p</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#Snd"><span class="id" title="constructor">Snd</span></a> <a class="idref" href="Cpdt.MoreDep.html#e'"><span class="id" title="variable">e'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The correctness theorem for <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a></span> turns out to be easy to prove, once we get over one serious hurdle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="cfold_correct"><span class="id" title="lemma">cfold_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.MoreDep.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>), <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.MoreDep.html#e"><span class="id" title="variable">e</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
The first remaining subgoal is:

<div class="paragraph"> </div>

   <br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) + <a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#NConst"><span class="id" title="constructor">NConst</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#n1"><span class="id" title="variable">n1</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#NConst"><span class="id" title="constructor">NConst</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#n2"><span class="id" title="variable">n2</span></a> ⇒ <a class="idref" href="Cpdt.DataStruct.html#NConst"><span class="id" title="constructor">NConst</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#n1"><span class="id" title="variable">n1</span></a> + <a class="idref" href="Cpdt.InductiveTypes.html#n2"><span class="id" title="variable">n2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Eq"><span class="id" title="constructor">Eq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Reflection.html#And"><span class="id" title="constructor">And</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#If"><span class="id" title="constructor">If</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Fst"><span class="id" title="constructor">Fst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Snd"><span class="id" title="constructor">Snd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#Eq"><span class="id" title="constructor">Eq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.DataStruct.html#BConst"><span class="id" title="constructor">BConst</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Reflection.html#And"><span class="id" title="constructor">And</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#If"><span class="id" title="constructor">If</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Pair"><span class="id" title="constructor">Pair</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Fst"><span class="id" title="constructor">Fst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Snd"><span class="id" title="constructor">Snd</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     We would like to do a case analysis on <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span>, and we attempt to do so in the way that has worked so far.
     <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.cfold"><span class="id" title="definition">cfold</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: e1 is used in hypothesis e
</pre>

<div class="paragraph"> </div>

    Coq gives us another cryptic error message.  Like so many others, this one basically means that Coq is not able to build some proof about dependent types.  It is hard to generate helpful and specific error messages for problems like this, since that would require some kind of understanding of the dependency structure of a piece of code.  We will encounter many examples of case-specific tricks for recovering from errors like this one.

<div class="paragraph"> </div>

    For our current proof, we can use a tactic <span class="inlinecode"><span class="id" title="var">dep_destruct</span></span> defined in the book's <span class="inlinecode"><span class="id" title="library">CpdtTactics</span></span> module.  General elimination/inversion of dependently typed hypotheses is undecidable, as witnessed by a simple reduction from the known-undecidable problem of higher-order unification, which has come up a few times already.  The tactic <span class="inlinecode"><span class="id" title="var">dep_destruct</span></span> makes a best effort to handle some common cases, relying upon the more primitive <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">destruction</span></span> tactic that comes with Coq.  In a future chapter, we will learn about the explicit manipulation of equality proofs that is behind <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">destruction</span></span>'s implementation, but for now, we treat it as a useful black box.  (In Chapter 12, we will also see how <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">destruction</span></span> forces us to make a larger philosophical commitment about our logic than we might like, and we will see some workarounds.) 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">e1</span>).<br/>

<br/>
</div>

<div class="doc">
This successfully breaks the subgoal into 5 new subgoals, one for each constructor of <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span> that could produce an <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span>.  Note that <span class="inlinecode"><span class="id" title="var">dep_destruct</span></span> is successful in ruling out the other cases automatically, in effect automating some of the work that we have done manually in implementing functions like <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#hd"><span class="id" title="definition">hd</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a></span>.

<div class="paragraph"> </div>

     This is the only new trick we need to learn to complete the proof.  We can back up and give a short, automated proof (which again is safe to skip and uses Ltac features not introduced yet). 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.MoreDep.html#NConst"><span class="id" title="constructor">NConst</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#pairOut"><span class="id" title="definition">pairOut</span></a> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> ?<span class="id" title="var">E</span>) <span class="id" title="keyword">with</span> <span class="id" title="constructor">Some</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> (<a class="idref" href="Cpdt.MoreDep.html#cfold"><span class="id" title="definition">cfold</span></a> <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="notation">(</span><span class="id" title="keyword">if</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span><span class="id" title="notation">)</span> <span class="id" title="notation">=</span> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
With this example, we get a first taste of how to build automated proofs that adapt automatically to changes in function definitions. 
<div class="paragraph"> </div>

<a name="lab54"></a><h1 class="section">Dependently Typed Red-Black Trees</h1>

<div class="paragraph"> </div>

 Red-black trees are a favorite purely functional data structure with an interesting invariant.  We can use dependent types to guarantee that operations on red-black trees preserve the invariant.  For simplicity, we specialize our red-black trees to represent sets of <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="color"><span class="id" title="inductive">color</span></a> : <span class="id" title="keyword">Set</span> := <a name="Red"><span class="id" title="constructor">Red</span></a> | <a name="Black"><span class="id" title="constructor">Black</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="rbtree"><span class="id" title="inductive">rbtree</span></a> : <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="Leaf"><span class="id" title="constructor">Leaf</span></a> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> 0<br/>
| <a name="RedNode"><span class="id" title="constructor">RedNode</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
| <a name="BlackNode"><span class="id" title="constructor">BlackNode</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
</div>

<div class="doc">
A value of type <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a></span> is a red-black tree whose root has color <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a></span> and that has black depth <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a></span>.  The latter property means that there are exactly <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a></span> black-colored nodes on any path from the root to a leaf. 
<div class="paragraph"> </div>

 At first, it can be unclear that this choice of type indices tracks any useful property.  To convince ourselves, we will prove that every red-black tree is balanced.  We will phrase our theorem in terms of a depth calculating function that ignores the extra information in the types.  It will be useful to parameterize this function over a combining operation, so that we can re-use the same code to calculate the minimum or maximum height among all paths from root to leaf. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Max</span> <span class="id" title="library">Min</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="depth"><span class="id" title="section">depth</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="depth.f"><span class="id" title="variable">f</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="depth"><span class="id" title="definition">depth</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">t1</span> <span class="id" title="var">_</span> <span class="id" title="var">t2</span> ⇒ <span class="id" title="constructor">S</span> (<a class="idref" href="Cpdt.MoreDep.html#depth.f"><span class="id" title="variable">f</span></a> (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="var">t1</span>) (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="var">t2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">t1</span> <span class="id" title="var">_</span> <span class="id" title="var">t2</span> ⇒ <span class="id" title="constructor">S</span> (<a class="idref" href="Cpdt.MoreDep.html#depth.f"><span class="id" title="variable">f</span></a> (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="var">t1</span>) (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="var">t2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="section">depth</span></a>.<br/>

<br/>
</div>

<div class="doc">
Our proof of balanced-ness decomposes naturally into a lower bound and an upper bound.  We prove the lower bound first.  Unsurprisingly, a tree's black depth provides such a bound on the minimum path length.  We use the richly typed procedure <span class="inlinecode"><span class="id" title="definition">min_dec</span></span> to do case analysis on whether <span class="inlinecode"><span class="id" title="abbreviation">min</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode"><span class="id" title="var">Y</span></span> equals <span class="inlinecode"><span class="id" title="var">X</span></span> or <span class="inlinecode"><span class="id" title="var">Y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="definition">min_dec</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">min_dec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a>, {<span class="id" title="abbreviation">min</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> = <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>} + {<span class="id" title="abbreviation">min</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> = <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>}
<div class="paragraph"> </div>

</span>   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="depth_min"><span class="id" title="lemma">depth_min</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>), <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">min</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">≥</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="abbreviation">min</span> ?<span class="id" title="var">X</span> ?<span class="id" title="var">Y</span>] ] ⇒ <span class="id" title="tactic">destruct</span> (<span class="id" title="definition">min_dec</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
There is an analogous upper-bound theorem based on black depth.  Unfortunately, a symmetric proof script does not suffice to establish it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="depth_max"><span class="id" title="lemma">depth_max</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>), <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">≤</span> 2 <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="abbreviation">max</span> ?<span class="id" title="var">X</span> ?<span class="id" title="var">Y</span>] ] ⇒ <span class="id" title="tactic">destruct</span> (<span class="id" title="definition">max_dec</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
Two subgoals remain.  One of them is: <br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">IHt1</span> : <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a> ≤ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + 0) + 1<br/>
&nbsp;&nbsp;<span class="id" title="var">IHt2</span> : <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a> ≤ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + 0) + 1<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <span class="id" title="abbreviation">max</span> (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a>) (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a>) = <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> (<a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a>) ≤ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> + 0) + 1<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   We see that <span class="inlinecode"><span class="id" title="var">IHt1</span></span> is <i>almost</i> the fact we need, but it is not quite strong enough.  We will need to strengthen our induction hypothesis to get the proof to go through. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
In particular, we prove a lemma that provides a stronger upper bound for trees with black root nodes.  We got stuck above in a case about a red root node.  Since red nodes have only black children, our IH strengthening will enable us to finish the proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="depth_max'"><span class="id" title="lemma">depth_max'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>), <span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">≤</span> 2 <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">≤</span> 2 <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="abbreviation">max</span> ?<span class="id" title="var">X</span> ?<span class="id" title="var">Y</span>] ] ⇒ <span class="id" title="tactic">destruct</span> (<span class="id" title="definition">max_dec</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">C</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="var">_</span> | <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The original theorem follows easily from the lemma.  We use the tactic <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span>, which, when <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#pf"><span class="id" title="variable">pf</span></a></span> proves the proposition <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>, changes the goal from <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span> to <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.Q"><span class="id" title="variable">Q</span></a></span>.  This transformation is useful because it makes the truth of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> manifest syntactically, so that automation machinery can rely on <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>, even if that machinery is not smart enough to establish <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> on its own. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="depth_max"><span class="id" title="lemma">depth_max</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>), <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">≤</span> 2 <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#depth_max'"><span class="id" title="lemma">depth_max'</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The final balance theorem establishes that the minimum and maximum path lengths of any tree are within a factor of two of each other. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="balanced"><span class="id" title="lemma">balanced</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>), 2 <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">min</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">+</span> 1 <span class="id" title="notation">≥</span> <a class="idref" href="Cpdt.MoreDep.html#depth"><span class="id" title="definition">depth</span></a> <span class="id" title="abbreviation">max</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#depth_min"><span class="id" title="lemma">depth_min</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#depth_max"><span class="id" title="lemma">depth_max</span></a> <span class="id" title="var">t</span>); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we are ready to implement an example operation on our trees, insertion.  Insertion can be thought of as breaking the tree invariants locally but then rebalancing.  In particular, in intermediate states we find red nodes that may have red children.  The type <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a></span> captures the idea of such a node, continuing to track black depth as a type index. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="rtree"><span class="id" title="inductive">rtree</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="RedNode'"><span class="id" title="constructor">RedNode'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span> <span class="id" title="var">n</span>, <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c1"><span class="id" title="variable">c1</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">
Before starting to define <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span>, we define predicates capturing when a data value is in the set represented by a normal or possibly invalid tree. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="present"><span class="id" title="section">present</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="present.x"><span class="id" title="variable">x</span></a> : <span class="id" title="inductive">nat</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="present"><span class="id" title="definition">present</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> ⇒ <span class="id" title="inductive">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">a</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <span class="id" title="var">y</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">a</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <span class="id" title="var">y</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="rpresent"><span class="id" title="definition">rpresent</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">a</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">=</span> <span class="id" title="var">y</span> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="section">present</span></a>.<br/>

<br/>
</div>

<div class="doc">
Insertion relies on two balancing operations.  It will be useful to give types to these operations using a relative of the subset types from last chapter.  While subset types let us pair a value with a proof about that value, here we want to pair a value with another non-proof dependently typed value.  The <span class="inlinecode"><span class="id" title="inductive">sigT</span></span> type fills this role. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "{ _ : _ &amp; _ }".<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Notation</span>            <span class="id" title="keyword">Scope</span>     <br/>
"{ x : A  &amp; P }" := <span class="id" title="inductive">sigT</span> (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> ⇒ <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>)
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="inductive">sigT</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">sigT</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> → <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">existT</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> : <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> → <span class="id" title="inductive">sigT</span> <a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 It will be helpful to define a concise notation for the constructor of <span class="inlinecode"><span class="id" title="inductive">sigT</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&quot;</span></a>{&lt; x &gt;}" := (<span class="id" title="constructor">existT</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
Each balance function is used to construct a new tree whose keys include the keys of two input trees, as well as a new key.  One of the two input trees may violate the red-black alternation invariant (that is, it has an <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a></span> type), while the other tree is known to be valid.  Crucially, the two input trees have the same black depth.

<div class="paragraph"> </div>

   A balance operation may return a tree whose root is of either color.  Thus, we use a <span class="inlinecode"><span class="id" title="inductive">sigT</span></span> type to package the result tree with the color of its root.  Here is the definition of the first balance operation, which applies when the possibly invalid <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a></span> belongs to the left of the valid <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a></span>.

<div class="paragraph"> </div>

   A quick word of encouragement: After writing this code, even I do not understand the precise details of how balancing works!  I consulted Chris Okasaki's paper "Red-Black Trees in a Functional Setting" and transcribed the code to use dependent types.  Luckily, the details are not so important here; types alone will tell us that insertion preserves balanced-ness, and we will prove that insertion produces trees containing the right keys.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="balance1"><span class="id" title="definition">balance1</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">a</span> : <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="var">data</span> : <span class="id" title="inductive">nat</span>) <span class="id" title="var">c2</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">c0</span> <span class="id" title="var">_</span> <span class="id" title="var">t1</span> <span class="id" title="var">y</span> <span class="id" title="var">t2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">t1</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c0</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="var">x</span> <span class="id" title="var">b</span>) <span class="id" title="var">y</span> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> <a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a>)<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">t1'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">t2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">x</span> <span class="id" title="var">c</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">d</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="var">y</span> <span class="id" title="var">b</span>) <span class="id" title="var">x</span> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">c</span> <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> <a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a>)<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">b</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">t</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> (<a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="var">y</span> <span class="id" title="var">b</span>) <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="var">t1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We apply a trick that I call the <i>convoy pattern</i>.  Recall that <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations only make it possible to describe a dependence of a <span class="inlinecode"><span class="id" title="keyword">match</span></span> <i>result type</i> on the discriminee.  There is no automatic refinement of the types of free variables.  However, it is possible to effect such a refinement by finding a way to encode free variable type dependencies in the <span class="inlinecode"><span class="id" title="keyword">match</span></span> result type, so that a <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause can express the connection.

<div class="paragraph"> </div>

   In particular, we can extend the <span class="inlinecode"><span class="id" title="keyword">match</span></span> to return <i>functions over the free variables whose types we want to refine</i>.  In the case of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#balance1"><span class="id" title="definition">balance1</span></a></span>, we only find ourselves wanting to refine the type of one tree variable at a time.  We match on one subtree of a node, and we want the type of the other subtree to be refined based on what we learn.  We indicate this with a <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause starting like <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode">...</span>, where <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> is bound in an <span class="inlinecode"><span class="id" title="keyword">in</span></span> pattern.  Such a <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression is applied immediately to the "old version" of the variable to be refined, and the type checker is happy.

<div class="paragraph"> </div>

   Here is the symmetric function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#balance2"><span class="id" title="definition">balance2</span></a></span>, for cases where the possibly invalid tree appears on the right rather than on the left. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="balance2"><span class="id" title="definition">balance2</span></a> <span class="id" title="var">n</span> (<span class="id" title="var">a</span> : <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="var">data</span> : <span class="id" title="inductive">nat</span>) <span class="id" title="var">c2</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">c0</span> <span class="id" title="var">_</span> <span class="id" title="var">t1</span> <span class="id" title="var">z</span> <span class="id" title="var">t2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">t1</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c0</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">y</span> <span class="id" title="var">c</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">d</span> <span class="id" title="var">a</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> <span class="id" title="var">b</span>) <span class="id" title="var">y</span> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">c</span> <span class="id" title="var">z</span> <a class="idref" href="Cpdt.MoreDep.html#d"><span class="id" title="variable">d</span></a>)<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">t1'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">t2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t2"><span class="id" title="variable">t2</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span> <span class="id" title="var">c</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="notation">}</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">c</span> <span class="id" title="var">z'</span> <span class="id" title="var">d</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> <a class="idref" href="Cpdt.MoreDep.html#b"><span class="id" title="variable">b</span></a>) <span class="id" title="var">z</span> (<a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">c</span> <span class="id" title="var">z'</span> <span class="id" title="var">d</span>)<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">b</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">t</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a><a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.MoreDep.html#data"><span class="id" title="variable">data</span></a> (<a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="var">z</span> <span class="id" title="var">b</span>)<a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="var">t1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now we are almost ready to get down to the business of writing an <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> function.  First, we enter a section that declares a variable <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span>, for the key we want to insert. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="insert"><span class="id" title="section">insert</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="insert.x"><span class="id" title="variable">x</span></a> : <span class="id" title="inductive">nat</span>.<br/>

<br/>
</div>

<div class="doc">
Most of the work of insertion is done by a helper function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span>, whose return types are expressed using a type-level function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="insResult"><span class="id" title="definition">insResult</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="notation">{</span> <span class="id" title="var">c'</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c'</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
That is, inserting into a tree with root color <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a></span> and black depth <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>, the variety of tree we get out depends on <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a></span>.  If we started with a red root, then we get back a possibly invalid tree of depth <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>.  If we started with a black root, we get back a valid tree of depth <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> with a root node of an arbitrary color.

<div class="paragraph"> </div>

     Here is the definition of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span>.  Again, we do not want to dwell on the functional details. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <a name="ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a> <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode"><span class="id" title="constructor">RedNode</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">b</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="definition">le_lt_dec</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> (<span class="id" title="definition">projT2</span> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">a</span>)) <span class="id" title="var">y</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> <span class="id" title="var">a</span> <span class="id" title="var">y</span> (<span class="id" title="definition">projT2</span> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">c1</span> <span class="id" title="var">c2</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">b</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="definition">le_lt_dec</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c1</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c1"><span class="id" title="variable">c1</span></a> <span class="id" title="var">_</span> <span class="id" title="notation">→</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">ins_a</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#balance1"><span class="id" title="definition">balance1</span></a> <a class="idref" href="Cpdt.MoreDep.html#ins_a"><span class="id" title="variable">ins_a</span></a> <span class="id" title="var">y</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">ins_a</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a> <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> (<span class="id" title="definition">projT2</span> <a class="idref" href="Cpdt.MoreDep.html#ins_a"><span class="id" title="variable">ins_a</span></a>) <span class="id" title="var">y</span> <span class="id" title="var">b</span> <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c2</span> <span class="id" title="keyword">return</span> <a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <span class="id" title="var">_</span> <span class="id" title="notation">→</span> <span class="id" title="var">_</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">ins_b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#balance2"><span class="id" title="definition">balance2</span></a> <a class="idref" href="Cpdt.MoreDep.html#ins_b"><span class="id" title="variable">ins_b</span></a> <span class="id" title="var">y</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">ins_b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">{&lt;</span></a> <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">a</span> <span class="id" title="var">y</span> (<span class="id" title="definition">projT2</span> <a class="idref" href="Cpdt.MoreDep.html#ins_b"><span class="id" title="variable">ins_b</span></a>) <a class="idref" href="Cpdt.MoreDep.html#12f2f7744047d54424240095f84ff736"><span class="id" title="notation">&gt;}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The one new trick is a variation of the convoy pattern.  In each of the last two pattern matches, we want to take advantage of the typing connection between the trees <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a></span>.  We might naively apply the convoy pattern directly on <span class="inlinecode"><a class="idref" href="Cpdt.GeneralRec.html#a"><span class="id" title="variable">a</span></a></span> in the first <span class="inlinecode"><span class="id" title="keyword">match</span></span> and on <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a></span> in the second.  This satisfies the type checker per se, but it does not satisfy the termination checker.  Inside each <span class="inlinecode"><span class="id" title="keyword">match</span></span>, we would be calling <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span> recursively on a locally bound variable.  The termination checker is not smart enough to trace the dataflow into that variable, so the checker does not know that this recursive argument is smaller than the original argument.  We make this fact clearer by applying the convoy pattern on <i>the result of a recursive call</i>, rather than just on that call's argument.

<div class="paragraph"> </div>

     Finally, we are in the home stretch of our effort to define <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span>.  We just need a few more definitions of non-recursive functions.  First, we need to give the final characterization of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span>'s return type.  Inserting into a red-rooted tree gives a black-rooted tree where black depth has increased, and inserting into a black-rooted tree gives a tree where black depth has stayed the same and where the root is an arbitrary color. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="insertResult"><span class="id" title="definition">insertResult</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="notation">{</span> <span class="id" title="var">c'</span> <span class="id" title="notation">:</span> <a class="idref" href="Cpdt.MoreDep.html#color"><span class="id" title="inductive">color</span></a> <span class="id" title="notation">&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <span class="id" title="var">c'</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
A simple clean-up procedure translates <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a></span>s into <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insertResult"><span class="id" title="definition">insertResult</span></a></span>s. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="makeRbtree"><span class="id" title="definition">makeRbtree</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> : <a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#insertResult"><span class="id" title="definition">insertResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#r"><span class="id" title="variable">r</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#RedNode'"><span class="id" title="constructor">RedNode'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#BlackNode"><span class="id" title="constructor">BlackNode</span></a> <span class="id" title="var">a</span> <span class="id" title="var">x</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#r"><span class="id" title="variable">r</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We modify Coq's default choice of implicit arguments for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#makeRbtree"><span class="id" title="definition">makeRbtree</span></a></span>, so that we do not need to specify the <span class="inlinecode"><a class="idref" href="Cpdt.Coinductive.html#c"><span class="id" title="variable">c</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> arguments explicitly in later calls. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.MoreDep.html#makeRbtree"><span class="id" title="definition">makeRbtree</span></a> [<span class="id" title="var">c</span> <span class="id" title="var">n</span>].<br/>

<br/>
</div>

<div class="doc">
Finally, we define <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> as a simple composition of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#makeRbtree"><span class="id" title="definition">makeRbtree</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="insert"><span class="id" title="definition">insert</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) : <a class="idref" href="Cpdt.MoreDep.html#insertResult"><span class="id" title="definition">insertResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#makeRbtree"><span class="id" title="definition">makeRbtree</span></a> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>).<br/>

<br/>
</div>

<div class="doc">
As we noted earlier, the type of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> guarantees that it outputs balanced trees whose depths have not increased too much.  We also want to know that <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> operates correctly on trees interpreted as finite sets, so we finish this section with a proof of that fact. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="insert.present"><span class="id" title="section">present</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="insert.present.z"><span class="id" title="variable">z</span></a> : <span class="id" title="inductive">nat</span>.<br/>

<br/>
</div>

<div class="doc">
The variable <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a></span> stands for an arbitrary key.  We will reason about <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a></span>'s presence in particular trees.  As usual, outside the section the theorems we prove will quantify over all possible keys, giving us the facts we wanted.

<div class="paragraph"> </div>

       We start by proving the correctness of the balance operations.  It is useful to define a custom tactic <span class="inlinecode"><span class="id" title="var">present_balance</span></span> that encapsulates the reasoning common to the two proofs.  We use the keyword <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> to assign a name to a proof script.  This particular script just iterates between <span class="inlinecode"><span class="id" title="var">crush</span></span> and identification of a tree that is being pattern-matched on and should be destructed. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">present_balance</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">T</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> <span class="id" title="var">T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">T</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.MoreDep.html#Leaf"><span class="id" title="constructor">Leaf</span></a> ⇒ <span class="id" title="var">_</span> | <span class="id" title="var">_</span> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] ⇒ <span class="id" title="var">dep_destruct</span> <span class="id" title="var">T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>

<br/>
</div>

<div class="doc">
The balance correctness theorems are simple first-order logic equivalences, where we use the function <span class="inlinecode"><span class="id" title="definition">projT2</span></span> to project the payload of a <span class="inlinecode"><span class="id" title="inductive">sigT</span></span> value. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="present_balance1"><span class="id" title="lemma">present_balance1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> (<span class="id" title="var">a</span> : <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="var">y</span> : <span class="id" title="inductive">nat</span>) <span class="id" title="var">c2</span> (<span class="id" title="var">b</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> (<span class="id" title="definition">projT2</span> (<a class="idref" href="Cpdt.MoreDep.html#balance1"><span class="id" title="definition">balance1</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Cpdt.MoreDep.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Cpdt.MoreDep.html#b"><span class="id" title="variable">b</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">↔</span> <a class="idref" href="Cpdt.MoreDep.html#rpresent"><span class="id" title="definition">rpresent</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#b"><span class="id" title="variable">b</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">present_balance</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="present_balance2"><span class="id" title="lemma">present_balance2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> (<span class="id" title="var">a</span> : <a class="idref" href="Cpdt.MoreDep.html#rtree"><span class="id" title="inductive">rtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>) (<span class="id" title="var">y</span> : <span class="id" title="inductive">nat</span>) <span class="id" title="var">c2</span> (<span class="id" title="var">b</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c2"><span class="id" title="variable">c2</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> (<span class="id" title="definition">projT2</span> (<a class="idref" href="Cpdt.MoreDep.html#balance2"><span class="id" title="definition">balance2</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Cpdt.MoreDep.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Cpdt.MoreDep.html#b"><span class="id" title="variable">b</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">↔</span> <a class="idref" href="Cpdt.MoreDep.html#rpresent"><span class="id" title="definition">rpresent</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#b"><span class="id" title="variable">b</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">present_balance</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
To state the theorem for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span>, it is useful to define a new type-level function, since <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span> returns different result types based on the type indices passed to it.  Recall that <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a></span> is the section variable standing for the key we are inserting. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="present_insResult"><span class="id" title="definition">present_insResult</span></a> <span class="id" title="var">c</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#insResult"><span class="id" title="definition">insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#rpresent"><span class="id" title="definition">rpresent</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#r"><span class="id" title="variable">r</span></a> <span class="id" title="notation">↔</span> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> (<span class="id" title="definition">projT2</span> <a class="idref" href="Cpdt.MoreDep.html#r"><span class="id" title="variable">r</span></a>) <span class="id" title="notation">↔</span> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now the statement and proof of the <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a></span> correctness theorem are straightforward, if verbose.  We proceed by induction on the structure of a tree, followed by finding case analysis opportunities on expressions we see being analyzed in <span class="inlinecode"><span class="id" title="keyword">if</span></span> or <span class="inlinecode"><span class="id" title="keyword">match</span></span> expressions.  After that, we pattern-match to find opportunities to use the theorems we proved about balancing.  Finally, we identify two variables that are asserted by some hypothesis to be equal, and we use that hypothesis to replace one variable with the other everywhere. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="present_ins"><span class="id" title="lemma">present_ins</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#present_insResult"><span class="id" title="definition">present_insResult</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<span class="id" title="keyword">if</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span>] |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">if</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span>] ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">C</span> <span class="id" title="keyword">with</span> <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> ⇒ <span class="id" title="var">_</span> | <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> ⇒ <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.MoreDep.html#balance1"><span class="id" title="definition">balance1</span></a> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span> ?<span class="id" title="var">C</span>] |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#present_balance1"><span class="id" title="lemma">present_balance1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.MoreDep.html#balance2"><span class="id" title="definition">balance2</span></a> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span> ?<span class="id" title="var">C</span>] |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#present_balance2"><span class="id" title="lemma">present_balance2</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.MoreDep.html#balance1"><span class="id" title="definition">balance1</span></a> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span> ?<span class="id" title="var">C</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#present_balance1"><span class="id" title="lemma">present_balance1</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<a class="idref" href="Cpdt.MoreDep.html#balance2"><span class="id" title="definition">balance2</span></a> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span> ?<span class="id" title="var">C</span>] ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#present_balance2"><span class="id" title="lemma">present_balance2</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">z</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="var">x</span> : <span class="id" title="inductive">nat</span> |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">z</span> <span class="id" title="notation">=</span> <span class="id" title="var">x</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The hard work is done.  The most readable way to state correctness of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> involves splitting the property into two color-specific theorems.  We write a tactic to encapsulate the reasoning steps that work to establish both facts. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">present_insert</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">t</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="Cpdt.MoreDep.html#present_ins"><span class="id" title="lemma">present_ins</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">dep_destruct</span> (<a class="idref" href="Cpdt.MoreDep.html#ins"><span class="id" title="definition">ins</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">tauto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="present_insert_Red"><span class="id" title="lemma">present_insert_Red</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Red"><span class="id" title="constructor">Red</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> (<a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">↔</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">present_insert</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="present_insert_Black"><span class="id" title="lemma">present_insert_Black</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.MoreDep.html#rbtree"><span class="id" title="inductive">rbtree</span></a> <a class="idref" href="Cpdt.MoreDep.html#Black"><span class="id" title="constructor">Black</span></a> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> (<span class="id" title="definition">projT2</span> (<a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">↔</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#insert.x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#present"><span class="id" title="definition">present</span></a> <a class="idref" href="Cpdt.MoreDep.html#insert.present.z"><span class="id" title="variable">z</span></a> <a class="idref" href="Cpdt.MoreDep.html#t"><span class="id" title="variable">t</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">present_insert</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#insert.present"><span class="id" title="section">present</span></a>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="section">insert</span></a>.<br/>

<br/>
</div>

<div class="doc">
We can generate executable OCaml code with the command <span class="inlinecode"><span class="id" title="keyword">Recursive</span></span> <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span>, which also automatically outputs the OCaml versions of all of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span>'s dependencies.  In our previous extractions, we wound up with clean OCaml code.  Here, we find uses of <tt>Obj.magic</tt>, OCaml's unsafe cast operator for tweaking the apparent type of an expression in an arbitrary way.  Casts appear for this example because the return type of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#insert"><span class="id" title="definition">insert</span></a></span> depends on the <i>value</i> of the function's argument, a pattern that OCaml cannot handle.  Since Coq's type system is much more expressive than OCaml's, such casts are unavoidable in general.  Since the OCaml type-checker is no longer checking full safety of programs, we must rely on Coq's extractor to use casts only in provably safe ways. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab55"></a><h1 class="section">A Certified Regular Expression Matcher</h1>

<div class="paragraph"> </div>

 Another interesting example is regular expressions with dependent types that express which predicates over strings particular regexps implement.  We can then assign a dependent type to a regular expression matching function, guaranteeing that it always decides the string property that we expect it to decide.

<div class="paragraph"> </div>

   Before defining the syntax of expressions, it is helpful to define an inductive type capturing the meaning of the Kleene star.  That is, a string <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> matches regular expression <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> if and only if <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> can be decomposed into a sequence of substrings that all match <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span>.  We use Coq's string support, which comes through a combination of the <span class="inlinecode"><span class="id" title="library">String</span></span> library and some parsing notations built into Coq.  Operators like <span class="inlinecode">++</span> and functions like <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> that we know from lists are defined again for strings.  Notation scopes help us control which versions we want to use in particular contexts. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Ascii</span> <span class="id" title="library">String</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">string_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="star"><span class="id" title="section">star</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="star.P"><span class="id" title="variable">P</span></a> : <span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="star"><span class="id" title="inductive">star</span></a> : <span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Empty"><span class="id" title="constructor">Empty</span></a> : <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> ""<br/>
&nbsp;&nbsp;| <a name="Iter"><span class="id" title="constructor">Iter</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#star.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> (<a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="section">star</span></a>.<br/>

<br/>
</div>

<div class="doc">
Now we can make our first attempt at defining a <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a></span> type that is indexed by predicates on strings, such that the index of a <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a></span> tells us which language (string predicate) it recognizes.  Here is a reasonable-looking definition that is restricted to constant characters and concatenation.  We use the constructor <span class="inlinecode"><span class="id" title="library">String</span></span>, which is the analogue of list cons for the type <span class="inlinecode"><span class="id" title="inductive">string</span></span>, where <span class="inlinecode">&quot;&quot;</span> is like list nil.
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> : (<span class="id" title="inductive">string</span> → <span class="id" title="keyword">Prop</span>) → <span class="id" title="keyword">Set</span> :=<br/>
| <a class="idref" href="Cpdt.MoreDep.html#Char"><span class="id" title="constructor">Char</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.MoreDep.html#ch"><span class="id" title="variable">ch</span></a> : <span class="id" title="inductive">ascii</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> ⇒ <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <span class="id" title="library">String</span> <a class="idref" href="Cpdt.MoreDep.html#ch"><span class="id" title="variable">ch</span></a> "")<br/>
| <a class="idref" href="Cpdt.MoreDep.html#Concat"><span class="id" title="constructor">Concat</span></a> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> : <span class="id" title="inductive">string</span> → <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">r1</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a>) (<span class="id" title="var">r2</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> ⇒ <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a>, <span class="id" title="tactic">∃</span> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>, <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> ++ <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a> ∧ <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s1"><span class="id" title="variable">s1</span></a> ∧ <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.Coinductive.html#stream_eq_loop.s2"><span class="id" title="variable">s2</span></a>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: Large non-propositional inductive types must be in Type
</pre>

<div class="paragraph"> </div>

What is a large inductive type?  In Coq, it is an inductive type that has a constructor that quantifies over some type of type <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.  We have not worked with <span class="inlinecode"><span class="id" title="keyword">Type</span></span> very much to this point.  Every term of CIC has a type, including <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, which are assigned type <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.  The type <span class="inlinecode"><span class="id" title="inductive">string</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> from the failed definition also has type <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.

<div class="paragraph"> </div>

It turns out that allowing large inductive types in <span class="inlinecode"><span class="id" title="keyword">Set</span></span> leads to contradictions when combined with certain kinds of classical logic reasoning.  Thus, by default, such types are ruled out.  There is a simple fix for our <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a></span> definition, which is to place our new type in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.  While fixing the problem, we also expand the list of constructors to cover the remaining regular expression operators. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="regexp"><span class="id" title="inductive">regexp</span></a> : <span class="id" title="notation">(</span><span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span><span class="id" title="notation">)</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Type</span> :=<br/>
| <a name="Char"><span class="id" title="constructor">Char</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ch</span> : <span class="id" title="inductive">ascii</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <span class="id" title="constructor">String</span> <a class="idref" href="Cpdt.MoreDep.html#ch"><span class="id" title="variable">ch</span></a> "")<br/>
| <a name="Concat"><span class="id" title="constructor">Concat</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> (<span class="id" title="var">r1</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P1"><span class="id" title="variable">P1</span></a>) (<span class="id" title="var">r2</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P2"><span class="id" title="variable">P2</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="notation">∃</span> <span class="id" title="var">s1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">s2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a>)<br/>
| <a name="Or"><span class="id" title="constructor">Or</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P1</span> <span class="id" title="var">P2</span> (<span class="id" title="var">r1</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P1"><span class="id" title="variable">P1</span></a>) (<span class="id" title="var">r2</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P2"><span class="id" title="variable">P2</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">∨</span> <a class="idref" href="Cpdt.MoreDep.html#P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a>)<br/>
| <a name="Star"><span class="id" title="constructor">Star</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> (<span class="id" title="var">r</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> (<a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a>).<br/>

<br/>
</div>

<div class="doc">
Many theorems about strings are useful for implementing a certified regexp matcher, and few of them are in the <span class="inlinecode"><span class="id" title="library">String</span></span> library.  The book source includes statements, proofs, and hint commands for a handful of such omitted theorems.  Since they are orthogonal to our use of dependent types, we hide them in the rendered versions of this book. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
A few auxiliary functions help us in our final matcher definition.  The function <span class="inlinecode"><span class="id" title="tactic">split</span></span> will be used to implement the regexp concatenation case. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="split"><span class="id" title="section">split</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <a name="split.P1"><span class="id" title="variable">P1</span></a> <a name="split.P2"><span class="id" title="variable">P2</span></a> : <span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="split.P1_dec"><span class="id" title="variable">P1_dec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="split.P2_dec"><span class="id" title="variable">P2_dec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span>.<br/>
</div>

<div class="doc">
We require a choice of two arbitrary string predicates and functions for deciding them. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="split.s"><span class="id" title="variable">s</span></a> : <span class="id" title="inductive">string</span>.<br/>
</div>

<div class="doc">
Our computation will take place relative to a single fixed string, so it is easiest to make it a <span class="inlinecode"><span class="id" title="keyword">Variable</span></span>, rather than an explicit argument to our functions. 
<div class="paragraph"> </div>

 The function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span> is the workhorse behind <span class="inlinecode"><span class="id" title="tactic">split</span></span>.  It searches through the possible ways of splitting <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> into two pieces, checking the two predicates against each such pair.  The execution of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span> progresses right-to-left, from splitting all of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> into the first piece to splitting all of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> into the second piece.  It takes an extra argument, <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>, which specifies how far along we are in this search process. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="split'"><span class="id" title="definition">split'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>, <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span><span class="id" title="notation">∃</span> <span class="id" title="var">s1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">s2</span><span class="id" title="notation">,</span> <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∨</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">n</span> : <span class="id" title="inductive">nat</span>) : <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span><span class="id" title="notation">∃</span> <span class="id" title="var">s1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">s2</span><span class="id" title="notation">,</span> <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∨</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="notation">Reduce</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#split.P1_dec"><span class="id" title="variable">P1_dec</span></a> "" <span class="id" title="notation">&amp;&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2_dec"><span class="id" title="variable">P2_dec</span></a> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#split.P1_dec"><span class="id" title="variable">P1_dec</span></a> (<span class="id" title="definition">substring</span> 0 (<span class="id" title="constructor">S</span> <span class="id" title="var">n'</span>) <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">&amp;&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2_dec"><span class="id" title="variable">P2_dec</span></a> (<span class="id" title="definition">substring</span> (<span class="id" title="constructor">S</span> <span class="id" title="var">n'</span>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <span class="id" title="constructor">S</span> <span class="id" title="var">n'</span>) <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">||</span> <a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">F</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span> 7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="definition">length</span> ?<span class="id" title="var">S</span> <span class="id" title="notation">≤</span> 0 |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">S</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="definition">length</span> ?<span class="id" title="var">S'</span> <span class="id" title="notation">≤</span> <span class="id" title="constructor">S</span> ?<span class="id" title="var">N</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> (<span class="id" title="abbreviation">eq_nat_dec</span> (<span class="id" title="definition">length</span> <span class="id" title="var">S'</span>) (<span class="id" title="constructor">S</span> <span class="id" title="var">N</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
There is one subtle point in the <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span> code that is worth mentioning.  The main body of the function is a <span class="inlinecode"><span class="id" title="keyword">match</span></span> on <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>.  In the case where <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> is known to be <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a></span>, we write <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a></span> in several places where we might be tempted to write <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span>.  However, without further work to craft proper <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations, the type-checker does not use the equality between <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a></span>.  Thus, it is common to see patterns repeated in <span class="inlinecode"><span class="id" title="keyword">match</span></span> case bodies in dependently typed Coq code.  We can at least use a <span class="inlinecode"><span class="id" title="keyword">let</span></span> expression to avoid copying the pattern more than once, replacing the first case body with:
     <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">let</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> := <a class="idref" href="Cpdt.Large.html#slow.S"><span class="id" title="variable">S</span></a> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.MoreDep.html#split.P1_dec"><span class="id" title="variable">P1_dec</span></a> (<span class="id" title="definition">substring</span> 0 <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <a class="idref" href="Cpdt.MoreDep.html#split.P2_dec"><span class="id" title="variable">P2_dec</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> - <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <a class="idref" href="Cpdt.InductiveTypes.html#map.F"><span class="id" title="variable">F</span></a> <a class="idref" href="Cpdt.Predicates.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="var">_</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     The <span class="inlinecode"><span class="id" title="tactic">split</span></span> function itself is trivial to implement in terms of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span>.  We just ask <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span> to begin its search with <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#length"><span class="id" title="definition">length</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="split"><span class="id" title="definition">split</span></a> : <span class="id" title="notation">{</span><span class="id" title="notation">∃</span> <span class="id" title="var">s1</span><span class="id" title="notation">,</span> <span class="id" title="notation">∃</span> <span class="id" title="var">s2</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span>, <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a> <span class="id" title="notation">→</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P1"><span class="id" title="variable">P1</span></a> <a class="idref" href="Cpdt.MoreDep.html#s1"><span class="id" title="variable">s1</span></a> <span class="id" title="notation">∨</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#split.P2"><span class="id" title="variable">P2</span></a> <a class="idref" href="Cpdt.MoreDep.html#s2"><span class="id" title="variable">s2</span></a><span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="notation">Reduce</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a> (<span class="id" title="var">n</span> := <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#split.s"><span class="id" title="variable">s</span></a>) <span class="id" title="var">_</span><span class="id" title="notation">)</span>); <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#split"><span class="id" title="section">split</span></a>.<br/>

<br/>
<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="Cpdt.MoreDep.html#split"><span class="id" title="definition">split</span></a> [<span class="id" title="var">P1</span> <span class="id" title="var">P2</span>].<br/>

<br/>

<br/>
</div>

<div class="doc">
One more helper function will come in handy: <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star"><span class="id" title="definition">dec_star</span></a></span>, for implementing another linear search through ways of splitting a string, this time for implementing the Kleene star. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="dec_star"><span class="id" title="section">dec_star</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="dec_star.P"><span class="id" title="variable">P</span></a> : <span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="dec_star.P_dec"><span class="id" title="variable">P_dec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span>.<br/>

<br/>
</div>

<div class="doc">
Some new lemmas and hints about the <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a></span> type family are useful.  We omit them here; they are included in the book source at this point. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
The function <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a></span> implements a single iteration of the star.  That is, it tries to find a string prefix matching <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span>, and it calls a parameter function on the remainder of the string. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="dec_star.dec_star''"><span class="id" title="section">dec_star''</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <span class="id" title="inductive">nat</span>.<br/>
</div>

<div class="doc">
Variable <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> is the length of the prefix of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> that we have already processed. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> : <span class="id" title="inductive">string</span> <span class="id" title="notation">→</span> <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a name="dec_star.dec_star''.P'_dec"><span class="id" title="variable">P'_dec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n'</span> : <span class="id" title="inductive">nat</span>, <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span>.<br/>

<br/>
</div>

<div class="doc">
When we use <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a></span>, we will instantiate <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'_dec"><span class="id" title="variable">P'_dec</span></a></span> with a function for continuing the search for more instances of <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> in <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span>. 
<div class="paragraph"> </div>

 Now we come to <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a></span> itself.  It takes as an input a natural <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a></span> that records how much of the string has been searched so far, as we did for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#split'"><span class="id" title="definition">split'</span></a></span>.  The return type expresses that <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a></span> is looking for an index into <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> that splits <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> into a nonempty prefix and a suffix, such that the prefix satisfies <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P"><span class="id" title="variable">P</span></a></span> and the suffix satisfies <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.P'"><span class="id" title="variable">P'</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="dec_star''"><span class="id" title="definition">dec_star''</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="inductive">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">{</span><span class="id" title="notation">∃</span> <span class="id" title="var">l'</span><span class="id" title="notation">,</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a><span class="id" title="notation">)</span>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="keyword">∀</span> <span class="id" title="var">l'</span>, <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∨</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a><span class="id" title="notation">)</span>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">l</span> : <span class="id" title="inductive">nat</span>) : <span class="id" title="notation">{</span><span class="id" title="notation">∃</span> <span class="id" title="var">l'</span><span class="id" title="notation">,</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) <span class="id" title="notation">∧</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a><span class="id" title="notation">)</span>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="keyword">∀</span> <span class="id" title="var">l'</span>, <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∨</span> <span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'"><span class="id" title="variable">P'</span></a> (<span class="id" title="definition">substring</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <a class="idref" href="Cpdt.MoreDep.html#l'"><span class="id" title="variable">l'</span></a><span class="id" title="notation">)</span>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">l'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star.P_dec"><span class="id" title="variable">P_dec</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> (<span class="id" title="constructor">S</span> <span class="id" title="var">l'</span>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) <span class="id" title="notation">&amp;&amp;</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.P'_dec"><span class="id" title="variable">P'_dec</span></a> (<span class="id" title="var">n'</span> := <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="constructor">S</span> <span class="id" title="var">l'</span>) <span class="id" title="var">_</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">||</span> <a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">l'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">F</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span> 7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : ?<span class="id" title="var">X</span> <span class="id" title="notation">≤</span> <span class="id" title="constructor">S</span> ?<span class="id" title="var">Y</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> (<span class="id" title="abbreviation">eq_nat_dec</span> <span class="id" title="var">X</span> (<span class="id" title="constructor">S</span> <span class="id" title="var">Y</span>)); <span class="id" title="var">crush</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''"><span class="id" title="section">dec_star''</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
The work of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a></span> is nested inside another linear search by <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star'"><span class="id" title="definition">dec_star'</span></a></span>, which provides the final functionality we need, but for arbitrary suffixes of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span>, rather than just for <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> overall. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="dec_star'"><span class="id" title="definition">dec_star'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">n'</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">n</span> <span class="id" title="var">n'</span> : <span class="id" title="inductive">nat</span>) : <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">→</span> <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> (<span class="id" title="definition">substring</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<span class="id" title="notation">}</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="notation">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">S</span> <span class="id" title="var">n''</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">le_gt_dec</span> (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">||</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star''"><span class="id" title="definition">dec_star''</span></a> (<span class="id" title="var">n</span> := <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>) (<a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">n0</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="notation">Reduce</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">n''</span> <a class="idref" href="Cpdt.MoreDep.html#n0"><span class="id" title="variable">n0</span></a> <span class="id" title="var">_</span><span class="id" title="notation">)</span>) (<span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">-</span> <a class="idref" href="Cpdt.MoreDep.html#n'"><span class="id" title="variable">n'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">F</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Cpdt.MoreDep.html#star_substring_inv"><span class="id" title="lemma">star_substring_inv</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H1</span> : <span class="id" title="var">_</span> <span class="id" title="notation">&lt;</span> <span class="id" title="var">_</span> <span class="id" title="notation">-</span> <span class="id" title="var">_</span>, <span class="id" title="var">H2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l'</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="var">_</span> <span class="id" title="notation">≤</span> <span class="id" title="var">_</span> <span class="id" title="notation">-</span> <span class="id" title="var">_</span> <span class="id" title="notation">→</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">_</span> (<span class="id" title="lemma">lt_le_S</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H1</span>)); <span class="id" title="tactic">tauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we have <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star"><span class="id" title="definition">dec_star</span></a></span>, defined by straightforward reduction from <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star'"><span class="id" title="definition">dec_star'</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="dec_star"><span class="id" title="definition">dec_star</span></a> : <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#star"><span class="id" title="inductive">star</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="notation">Reduce</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#dec_star'"><span class="id" title="definition">dec_star'</span></a> (<span class="id" title="var">n</span> := <span class="id" title="definition">length</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) 0 <span class="id" title="var">_</span><span class="id" title="notation">)</span>); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star"><span class="id" title="section">dec_star</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
With these helper functions completed, the implementation of our <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a></span> function is refreshingly straightforward.  We only need one small piece of specific tactic work beyond what <span class="inlinecode"><span class="id" title="var">crush</span></span> does for us. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="matches"><span class="id" title="definition">matches</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> (<span class="id" title="var">r</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a>) <span class="id" title="var">s</span>, <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> <span class="id" title="var">P</span> (<span class="id" title="var">r</span> : <a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a>) <span class="id" title="var">s</span> : <span class="id" title="notation">{</span><a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> <span class="id" title="notation">+</span> <span class="id" title="notation">{</span><span class="id" title="notation">¬</span> <a class="idref" href="Cpdt.MoreDep.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">}</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.MoreDep.html#r"><span class="id" title="variable">r</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Char"><span class="id" title="constructor">Char</span></a> <span class="id" title="var">ch</span> ⇒ <span class="id" title="definition">string_dec</span> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a> (<span class="id" title="constructor">String</span> <span class="id" title="var">ch</span> "")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Concat"><span class="id" title="constructor">Concat</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> ⇒ <span class="id" title="notation">Reduce</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.MoreDep.html#split"><span class="id" title="definition">split</span></a> (<a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r1</span>) (<a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r2</span>) <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Or"><span class="id" title="constructor">Or</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r1</span> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">||</span> <a class="idref" href="Cpdt.MoreDep.html#F"><span class="id" title="variable">F</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r2</span> <a class="idref" href="Cpdt.MoreDep.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.MoreDep.html#Star"><span class="id" title="constructor">Star</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Cpdt.MoreDep.html#dec_star"><span class="id" title="definition">dec_star</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="constructor">eq_refl</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">tauto</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
It is interesting to pause briefly to consider alternate implementations of <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a></span>.  Dependent types give us much latitude in how specific correctness properties may be encoded with types.  For instance, we could have made <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a></span> a non-indexed inductive type, along the lines of what is possible in traditional ML and Haskell.  We could then have implemented a recursive function to map <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#regexp"><span class="id" title="inductive">regexp</span></a></span>s to their intended meanings, much as we have done with types and programs in other examples.  That style is compatible with the <span class="inlinecode"><span class="id" title="tactic">refine</span></span>-based approach that we have used here, and it might be an interesting exercise to redo the code from this subsection in that alternate style or some further encoding of the reader's choice.  The main advantage of indexed inductive types is that they generally lead to the smallest amount of code. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Many regular expression matching problems are easy to test.  The reader may run each of the following queries to verify that it gives the correct answer.  We use evaluation strategy <span class="inlinecode"><span class="id" title="tactic">hnf</span></span> to reduce each term to <i>head-normal form</i>, where the datatype constructor used to build its value is known.  (Further reduction would involve wasteful simplification of proof terms justifying the answers of our procedures.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a name="a_star"><span class="id" title="definition">a_star</span></a> := <a class="idref" href="Cpdt.MoreDep.html#Star"><span class="id" title="constructor">Star</span></a> (<a class="idref" href="Cpdt.MoreDep.html#Char"><span class="id" title="constructor">Char</span></a> "a"%<span class="id" title="var">char</span>).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a> <a class="idref" href="Cpdt.MoreDep.html#a_star"><span class="id" title="definition">a_star</span></a> "".<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a> <a class="idref" href="Cpdt.MoreDep.html#a_star"><span class="id" title="definition">a_star</span></a> "a".<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a> <a class="idref" href="Cpdt.MoreDep.html#a_star"><span class="id" title="definition">a_star</span></a> "b".<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.MoreDep.html#matches"><span class="id" title="definition">matches</span></a> <a class="idref" href="Cpdt.MoreDep.html#a_star"><span class="id" title="definition">a_star</span></a> "aa".<br/>

<br/>
</div>

<div class="doc">
Evaluation inside Coq does not scale very well, so it is easy to build other tests that run for hours or more.  Such cases are better suited to execution with the extracted OCaml code. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>